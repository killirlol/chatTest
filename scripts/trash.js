import { O as Vt } from "./editor-page.3f8a3351.js"; import "./donations.f1f09a51.js"; var V = Object.prototype.hasOwnProperty, yt = Object.prototype.toString, st = Object.defineProperty, it = Object.getOwnPropertyDescriptor, rt = function (t) { return typeof Array.isArray == "function" ? Array.isArray(t) : yt.call(t) === "[object Array]" }, nt = function (t) { if (!t || yt.call(t) !== "[object Object]") return !1; var e = V.call(t, "constructor"), s = t.constructor && t.constructor.prototype && V.call(t.constructor.prototype, "isPrototypeOf"); if (t.constructor && !e && !s) return !1; var i; for (i in t); return typeof i > "u" || V.call(t, i) }, ut = function (t, e) { st && e.name === "__proto__" ? st(t, e.name, { enumerable: !0, configurable: !0, value: e.newValue, writable: !0 }) : t[e.name] = e.newValue }, ot = function (t, e) { if (e === "__proto__") if (V.call(t, e)) { if (it) return it(t, e).value } else return; return t[e] }, L = function r() { var t, e, s, i, n, u, o = arguments[0], l = 1, a = arguments.length, c = !1; for (typeof o == "boolean" && (c = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); l < a; ++l)if (t = arguments[l], t != null) for (e in t) s = ot(o, e), i = ot(t, e), o !== i && (c && i && (nt(i) || (n = rt(i))) ? (n ? (n = !1, u = s && rt(s) ? s : []) : u = s && nt(s) ? s : {}, ut(o, { name: e, newValue: r(c, u, i) })) : typeof i < "u" && ut(o, { name: e, newValue: i })); return o };/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const wt = new WeakMap, Ut = r => (...t) => { const e = r(...t); return wt.set(e, !0), e }, P = r => typeof r == "function" && wt.has(r);/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const at = window.customElements !== void 0 && window.customElements.polyfillWrapFlushCallback !== void 0, jt = (r, t, e = null, s = null) => { let i = t; for (; i !== e;) { const n = i.nextSibling; r.insertBefore(i, s), i = n } }, vt = (r, t, e = null) => { let s = t; for (; s !== e;) { const i = s.nextSibling; r.removeChild(s), s = i } }, F = {};/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const B = `{{lit-${String(Math.random()).slice(2)}}}`, Ct = `<!--${B}-->`, lt = new RegExp(`${B}|${Ct}`), Et = "$lit$"; class Ht { constructor(t, e) { this.parts = [], this.element = e; let s = -1, i = 0; const n = [], u = o => { const l = o.content, a = document.createTreeWalker(l, 133, null, !1); let c, d; for (; a.nextNode();) { s++, c = d; const h = d = a.currentNode; if (h.nodeType === 1) { if (h.hasAttributes()) { const p = h.attributes; let f = 0; for (let g = 0; g < p.length; g++)p[g].value.indexOf(B) >= 0 && f++; for (; f-- > 0;) { const g = t.strings[i], y = Ft.exec(g)[2], w = y.toLowerCase() + Et, et = h.getAttribute(w).split(lt); this.parts.push({ type: "attribute", index: s, name: y, strings: et }), h.removeAttribute(w), i += et.length - 1 } } h.tagName === "TEMPLATE" && u(h) } else if (h.nodeType === 3) { const p = h.nodeValue; if (p.indexOf(B) < 0) continue; const f = h.parentNode, g = p.split(lt), y = g.length - 1; i += y; for (let w = 0; w < y; w++)f.insertBefore(g[w] === "" ? _() : document.createTextNode(g[w]), h), this.parts.push({ type: "node", index: s++ }); f.insertBefore(g[y] === "" ? _() : document.createTextNode(g[y]), h), n.push(h) } else if (h.nodeType === 8) if (h.nodeValue === B) { const p = h.parentNode, f = h.previousSibling; f === null || f !== c || f.nodeType !== Node.TEXT_NODE ? p.insertBefore(_(), h) : s--, this.parts.push({ type: "node", index: s++ }), n.push(h), h.nextSibling === null ? p.insertBefore(_(), h) : s--, d = c, i++ } else { let p = -1; for (; (p = h.nodeValue.indexOf(B, p + 1)) !== -1;)this.parts.push({ type: "node", index: -1 }) } } }; u(e); for (const o of n) o.parentNode.removeChild(o) } } const Kt = r => r.index !== -1, _ = () => document.createComment(""), Ft = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class qt { constructor(t, e, s) { this._parts = [], this.template = t, this.processor = e, this.options = s } update(t) { let e = 0; for (const s of this._parts) s !== void 0 && s.setValue(t[e]), e++; for (const s of this._parts) s !== void 0 && s.commit() } _clone() { const t = at ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0), e = this.template.parts; let s = 0, i = 0; const n = u => { const o = document.createTreeWalker(u, 133, null, !1); let l = o.nextNode(); for (; s < e.length && l !== null;) { const a = e[s]; if (!Kt(a)) this._parts.push(void 0), s++; else if (i === a.index) { if (a.type === "node") { const c = this.processor.handleTextExpression(this.options); c.insertAfterNode(l), this._parts.push(c) } else this._parts.push(...this.processor.handleAttributeExpressions(l, a.name, a.strings, this.options)); s++ } else i++, l.nodeName === "TEMPLATE" && n(l.content), l = o.nextNode() } }; return n(t), at && (document.adoptNode(t), customElements.upgrade(t)), t } }/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class q { constructor(t, e, s, i) { this.strings = t, this.values = e, this.type = s, this.processor = i } getHTML() { const t = this.strings.length - 1; let e = ""; for (let s = 0; s < t; s++) { const i = this.strings[s]; let n = !1; e += i.replace(Ft, (u, o, l, a) => (n = !0, o + l + Et + a + B)), n || (e += Ct) } return e + this.strings[t] } getTemplateElement() { const t = document.createElement("template"); return t.innerHTML = this.getHTML(), t } } class Xt extends q { getHTML() { return `<svg>${super.getHTML()}</svg>` } getTemplateElement() { const t = super.getTemplateElement(), e = t.content, s = e.firstChild; return e.removeChild(s), jt(e, s.firstChild), t } }/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const X = r => r === null || !(typeof r == "object" || typeof r == "function"); class At { constructor(t, e, s) { this.dirty = !0, this.element = t, this.name = e, this.strings = s, this.parts = []; for (let i = 0; i < s.length - 1; i++)this.parts[i] = this._createPart() } _createPart() { return new xt(this) } _getValue() { const t = this.strings, e = t.length - 1; let s = ""; for (let i = 0; i < e; i++) { s += t[i]; const n = this.parts[i]; if (n !== void 0) { const u = n.value; if (u != null && (Array.isArray(u) || typeof u != "string" && u[Symbol.iterator])) for (const o of u) s += typeof o == "string" ? o : String(o); else s += typeof u == "string" ? u : String(u) } } return s += t[e], s } commit() { this.dirty && (this.dirty = !1, this.element.setAttribute(this.name, this._getValue())) } } class xt { constructor(t) { this.value = void 0, this.committer = t } setValue(t) { t !== F && (!X(t) || t !== this.value) && (this.value = t, P(t) || (this.committer.dirty = !0)) } commit() { for (; P(this.value);) { const t = this.value; this.value = F, t(this) } this.value !== F && this.committer.commit() } } class R { constructor(t) { this.value = void 0, this._pendingValue = void 0, this.options = t } appendInto(t) { this.startNode = t.appendChild(_()), this.endNode = t.appendChild(_()) } insertAfterNode(t) { this.startNode = t, this.endNode = t.nextSibling } appendIntoPart(t) { t._insert(this.startNode = _()), t._insert(this.endNode = _()) } insertAfterPart(t) { t._insert(this.startNode = _()), this.endNode = t.endNode, t.endNode = this.startNode } setValue(t) { this._pendingValue = t } commit() { for (; P(this._pendingValue);) { const e = this._pendingValue; this._pendingValue = F, e(this) } const t = this._pendingValue; t !== F && (X(t) ? t !== this.value && this._commitText(t) : t instanceof q ? this._commitTemplateResult(t) : t instanceof Node ? this._commitNode(t) : Array.isArray(t) || t[Symbol.iterator] ? this._commitIterable(t) : this._commitText(t)) } _insert(t) { this.endNode.parentNode.insertBefore(t, this.endNode) } _commitNode(t) { this.value !== t && (this.clear(), this._insert(t), this.value = t) } _commitText(t) { const e = this.startNode.nextSibling; t = t == null ? "" : t, e === this.endNode.previousSibling && e.nodeType === Node.TEXT_NODE ? e.textContent = t : this._commitNode(document.createTextNode(typeof t == "string" ? t : String(t))), this.value = t } _commitTemplateResult(t) { const e = this.options.templateFactory(t); if (this.value && this.value.template === e) this.value.update(t.values); else { const s = new qt(e, t.processor, this.options), i = s._clone(); s.update(t.values), this._commitNode(i), this.value = s } } _commitIterable(t) { Array.isArray(this.value) || (this.value = [], this.clear()); const e = this.value; let s = 0, i; for (const n of t) i = e[s], i === void 0 && (i = new R(this.options), e.push(i), s === 0 ? i.appendIntoPart(this) : i.insertAfterPart(e[s - 1])), i.setValue(n), i.commit(), s++; s < e.length && (e.length = s, this.clear(i && i.endNode)) } clear(t = this.startNode) { vt(this.startNode.parentNode, t.nextSibling, this.endNode) } } class Yt { constructor(t, e, s) { if (this.value = void 0, this._pendingValue = void 0, s.length !== 2 || s[0] !== "" || s[1] !== "") throw new Error("Boolean attributes can only contain a single expression"); this.element = t, this.name = e, this.strings = s } setValue(t) { this._pendingValue = t } commit() { for (; P(this._pendingValue);) { const e = this._pendingValue; this._pendingValue = F, e(this) } if (this._pendingValue === F) return; const t = !!this._pendingValue; this.value !== t && (t ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name)), this.value = t, this._pendingValue = F } } class Jt extends At { constructor(t, e, s) { super(t, e, s), this.single = s.length === 2 && s[0] === "" && s[1] === "" } _createPart() { return new Zt(this) } _getValue() { return this.single ? this.parts[0].value : super._getValue() } commit() { this.dirty && (this.dirty = !1, this.element[this.name] = this._getValue()) } } class Zt extends xt { } let _t = !1; try { const r = { get capture() { return _t = !0, !1 } }; window.addEventListener("test", r, r), window.removeEventListener("test", r, r) } catch { } class Gt { constructor(t, e, s) { this.value = void 0, this._pendingValue = void 0, this.element = t, this.eventName = e, this.eventContext = s, this._boundHandleEvent = i => this.handleEvent(i) } setValue(t) { this._pendingValue = t } commit() { for (; P(this._pendingValue);) { const n = this._pendingValue; this._pendingValue = F, n(this) } if (this._pendingValue === F) return; const t = this._pendingValue, e = this.value, s = t == null || e != null && (t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive), i = t != null && (e == null || s); s && this.element.removeEventListener(this.eventName, this._boundHandleEvent, this._options), i && (this._options = Qt(t), this.element.addEventListener(this.eventName, this._boundHandleEvent, this._options)), this.value = t, this._pendingValue = F } handleEvent(t) { typeof this.value == "function" ? this.value.call(this.eventContext || this.element, t) : this.value.handleEvent(t) } } const Qt = r => r && (_t ? { capture: r.capture, passive: r.passive, once: r.once } : r.capture);/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class te { handleAttributeExpressions(t, e, s, i) { const n = e[0]; return n === "." ? new Jt(t, e.slice(1), s).parts : n === "@" ? [new Gt(t, e.slice(1), i.eventContext)] : n === "?" ? [new Yt(t, e.slice(1), s)] : new At(t, e, s).parts } handleTextExpression(t) { return new R(t) } } const bt = new te;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function ee(r) { let t = ct.get(r.type); t === void 0 && (t = { stringsArray: new WeakMap, keyString: new Map }, ct.set(r.type, t)); let e = t.stringsArray.get(r.strings); if (e !== void 0) return e; const s = r.strings.join(B); return e = t.keyString.get(s), e === void 0 && (e = new Ht(r, r.getTemplateElement()), t.keyString.set(s, e)), t.stringsArray.set(r.strings, e), e } const ct = new Map;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const dt = new WeakMap, k = (r, t, e) => { let s = dt.get(t); s === void 0 && (vt(t, t.firstChild), dt.set(t, s = new R(Object.assign({ templateFactory: ee }, e))), s.appendInto(t)), s.setValue(r), s.commit() };/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const m = (r, ...t) => new q(r, t, "html", bt), Y = (r, ...t) => new Xt(r, t, "svg", bt);/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const ht = new WeakMap, se = Ut(r => t => { if (!(t instanceof R)) throw new Error("unsafeHTML can only be used in text bindings"); if (ht.get(t) === r && X(r)) return; const s = document.createElement("template"); s.innerHTML = r, t.setValue(document.importNode(s.content, !0)), ht.set(t, r) }); function J(r) { return (t, e) => { const s = t ? `_${t}` : "", i = e ? s ? ` ${r}${s}__${e}` : `__${e}` : ""; return r + s + i } } function Bt(r) { return kt(r, "[node-id]") } function I(r) { return r && r.getAttribute("node-id") } function x(r, t) { return I(r) === t ? r : r.querySelector(`[node-id="${t}"]`) } function kt(r, t) { return r.nodeType !== Node.ELEMENT_NODE && (r = r.parentNode), r.closest(t) } function Z(r, t = "") {
	const e = r.textContent; return t.slice(-1) !== `
`? e : e.slice(-1) === `
`? e.slice(0, -1) : e
} function $t(r) { return r ? r.toString() : "" } function Tt(r) { if (!r) return ""; const t = r.getRangeAt(0); if (!t) return ""; const e = t.cloneContents(), s = document.createElement("DIV"); return s.appendChild(e), s.innerHTML } function G(r) { return r ? r.nodeType === r.TEXT_NODE ? r : G(r.lastChild) : null } var ie = Object.freeze({ bem: J, getModelElement: Bt, getModelElementKey: I, findModelElement: x, closest: kt, getNodeText: Z, getSelectionText: $t, getSelectionHTML: Tt, lastTextNode: G }); function N(r, t, e) { return function (s, i, n) { return new r(s, i, n, t, e).el } } function j(r, t) { return r.id + (t ? `.${t}` : "") } class S { static get tag() { return null } static get class() { return null } get item() { return this._item || {} } set item(t) { this._item = t } get id() { return this.item.id ? j(this.item, this.suffix) : null } get tag() { return this._tag || this.constructor.tag || this.item.name || null } set tag(t) { this._tag = t } get attributes() { return this.item && this.item.attributes || {} } get allowedAttributes() { return [] } constructor(t, e, s, i = null, n = null) { this.editor = t, this.model = e, this.tag = i, this.suffix = n, this.class = this.constructor.class ? J(this.constructor.class) : null, this.create(s), this.update ? this.update(s) : this.item = s } create(t) { const e = this.el = document.createElement(this.tag || t.name); return e.setAttribute("node-id", this.id || j(t, this.suffix)), e.widget = this, this.class && e.classList.add(this.class()), this.update && (e.update = s => this.update(s)), e } update(t) { this.attributes !== t.attributes && this.updateAttributes(t.attributes), this.item !== t && (this.item = t) } updateAttributes(t = {}) { const e = this.allowedAttributes || [], s = this.el, i = Object.keys(t || {}), n = Object.keys(s.dataset || {}); i.concat(n).forEach(o => { const l = s.dataset[o]; !e.includes(o) || !t[o] ? delete s.dataset[o] : l !== t[o] && (s.dataset[o] = t[o]) }) } } function E(r) { const t = window.getSelection(), e = t.rangeCount && t.getRangeAt(0); if (e && Nt(e, r)) return ue(e, r) } function C(r, t, e) { const s = It(r, t, e); if (s) { const i = window.getSelection(); if (i.rangeCount) { const n = i.getRangeAt(0), u = n.compareBoundaryPoints(Range.START_TO_START, s), o = n.compareBoundaryPoints(Range.END_TO_END, s); if (u === 0 && o === 0) return } i.empty(), i.addRange(s) } } function D(r) { const t = E(r); return t && T(t) } function T(r) { const { collapsed: t } = r, e = A(r.startContainer, r.startOffset), s = t ? { ...e } : A(r.endContainer, r.endOffset); return e && s ? { from: e, to: s, collapsed: t } : null } function It(r = document, t, e) { const s = H(r, t), i = e ? H(r, e) : s; if (s && i) { const n = document.createRange(); return n.setStart(s.container, s.offset), n.setEnd(i.container, i.offset), n } } function A(r, t) { const e = Bt(r); if (!e) return null; r.nodeType !== Node.TEXT_NODE && (r = r.childNodes[t] ? ne(r.childNodes[t]) : r, t = 0); const s = e.ownerDocument.createTreeWalker(e, NodeFilter.SHOW_TEXT, { acceptNode: u => u.parentNode.isContentEditable }); let i = 0, n; for (; n = s.nextNode();) { if (n === r) { i += t; break } i += n.nodeValue.length } return { key: I(e), pos: i } } function H(r, t) { const e = x(r, t.key); if (e) { const s = e.ownerDocument.createTreeWalker(e, NodeFilter.SHOW_TEXT, { acceptNode: o => o.parentNode.isContentEditable }); let { pos: i } = t, n, u; for (; u = s.nextNode();) { if (n = u.nodeValue.length, i <= n) return { container: u, offset: i }; i -= n } return { container: e, offset: 0 } } } function re(r, t) { if (document.caretPositionFromPoint) { const e = document.caretPositionFromPoint(r, t); return A(e.offsetNode, e.offset) } if (document.caretRangeFromPoint) { const e = document.caretRangeFromPoint(r, t); return A(e.startContainer, e.startOffset) } } function ne(r) { return r.nodeType === Node.TEXT_NODE ? r : r.ownerDocument.createTreeWalker(r, NodeFilter.SHOW_TEXT).nextNode() } function Nt(r, t) { return t.contains(r.commonAncestorContainer) && t.contains(r.startContainer) && t.contains(r.endContainer) } function ue(r, t) { if (!Nt(r, t)) return null; const e = document.createRange(), s = { node: r.startContainer, offset: r.startOffset }, i = { node: r.endContainer, offset: r.endOffset }; return [s, i].forEach(n => { let { node: u, offset: o } = n; for (; !(u instanceof Text) && u.childNodes.length > 0;)if (u.childNodes.length > o) u = u.childNodes[o], o = 0; else if (u.childNodes.length === o) u = u.lastChild, u instanceof Text ? o = u.data.length : u.childNodes.length > 0 ? o = u.childNodes.length : o = 0; else break; n.node = u, n.offset = o }), e.native = r, e.setStart(s.node, s.offset), e.setEnd(i.node, i.offset), e } var oe = Object.freeze({ getRange: E, setRange: C, getModelRange: D, rangeToLocation: T, locationToRange: It, rangeBoundToLocation: A, locationToRangeBound: H, caretPositionFromPoint: re }); function Q(r) { return Object.keys(r.format).filter(t => r.format[t]) } function tt(r, t) { let e = t ? r.value[t] : r.value; return e != null ? e : "" } function St(r, t) { return t ? r.value[t].attributes : r.attributes } function b(r) { return typeof r == "string" ? r : typeof r.map != "function" ? "" : r.map(t => t.text).join("") } function Mt(r, t) { const e = A(t.startContainer, t.startOffset); if (e) { const s = Pt(r, e); if (s) return Q(s) } return [] } function K(r, t) { const e = A(t.startContainer, t.startOffset); if (e) { const s = z(r, e); return s ? s.name : null } } function ae(r, t) { const e = A(t.startContainer, t.startOffset); if (e) { const s = z(r, e); return s && s.attributes && s.attributes.align ? s.attributes.align : null } } function le(r, t) { const e = A(t.startContainer, t.startOffset); if (!e) return null; const s = z(r, e); if (!s) return null; let i = null; return i = s.attributes && s.attributes.anchor ? s.attributes.anchor : null, i || (i = s.value && s.value.anchor ? s.value.anchor : null), i } function ce(r, t) { const e = A(t.startContainer, t.startOffset); if (e) { const s = z(r, e); return s && s.attributes && s.attributes.lang ? s.attributes.lang : null } } function Pt(r, t) { const e = r.getValue(t.key); if (Array.isArray(e)) { for (let s = 0, i = 0, n; s < e.length; s++)if (n = e[s], i += n.text.length, i > t.pos) return n } } function de(r, t) { const e = r.getValue(t.key); if (e) for (let s = 0, i = 0, n; s < e.length; s++) { if (n = e[s], i + n.text.length >= t.pos) return { index: s, pos: t.pos - i, token: n }; i += n.text.length } } function z(r, t) { return t.key.split(".").length > 1 ? null : r.getById(parseInt(t.key)) } var he = Object.freeze({ getFormat: Q, getValue: tt, getAttributes: St, plainText: b, formatForRange: Mt, nameForRange: K, alignmentForRange: ae, anchorForRange: le, langForRange: ce, tokenForLocation: Pt, tokenLocForLocation: de, itemForLocation: z }); class Lt extends S {
	get allowedAttributes() { return ["align", "anchor"] } update(t) { const e = this.getAttributes(t); this.attributes !== e && this.updateAttributes(e), this.item !== t && (this.item = t, this.reconcile()) } reconcile() {
		const t = this.getValue(this.item), e = this.el, s = t.length - 1; for (t.forEach((i, n) => {
			const u = e.childNodes[n], o = Q(i), l = o.length ? 1 : 3, a = o.join(" "); let c = i.text; if (n === s && c.slice(-1) === `
`&& (c += `
`), !u || u.nodeType !== l) { const d = this.createNode(c, a); u ? e.insertBefore(d, u) : e.appendChild(d) } else u.textContent !== c && (u.textContent = c), l === 1 && u.className !== a && (u.className = a)
		}); e.childNodes.length > t.length;)e.childNodes[t.length].remove()
	} createNode(t, e) { if (e) { const s = document.createElement("span"); return s.className = e, s.textContent = t, s } return document.createTextNode(t) } getItem(t) { return this.suffix ? t.value[this.suffix] : t } getAttributes(t) { return St(t, this.suffix) } getValue(t) { return tt(t, this.suffix) }
} var fe = N(Lt); class Rt extends S { update(t) { const e = this.getText(t.value), s = this.prevValue; return e !== s ? (this.item = t, this.el.textContent = this.prevValue = e, !0) : !1 } getText(t) { return t != null ? t : "" } } var pe = N(Rt); class ge extends S { static get tag() { return "section" } get allowedAttributes() { return ["anchor"] } create(t) { const e = this.el = document.createElement(this.tag || t.name); return e.setAttribute("node-id", this.id || j(t, this.suffix)), this.class && e.classList.add(this.class()), this.updateAttributes && (e.updateAttributes = s => this.updateAttributes(s)), e } updateAttributes(t = {}) { super.updateAttributes(t), this.el.style.backgroundColor = t.bg || "", this.el.style.color = t.color || "" } } var me = N(ge); const De = (r, t) => JSON.stringify(r) === JSON.stringify(t); class ye extends S {
	static get tag() { return "nav" } static get class() { return "contents" } get contents() { return this.model.getContents().map(({ link: e, level: s, text: i }) => ({ link: e, level: s, text: i })) } get items() { return this.item && this.item.value && this.item["contents-item"] || this.contents } constructor() { super(...arguments), this.editor.on("update", () => this.updateProps()), this.inFocus = !1 } create(t) { const e = super.create(t); return e.contentEditable = !1, e } update(t) { this.item !== t && (this.item = t, this.updateProps(), this.render()) } updateProps() { const t = this.contents; De(this.item.value["contents-item"], t) || this.setProps(t) } setProps(t) { setTimeout(() => { this.model.assign(this.item.id, { "contents-item": t }, !1) }, 0) } render() {
		const t = this.items.filter(u => u.text && u.link), e = this.class; let s, i; if (t.length > 0) s = m`
			<ul class="${e("list")}" draggable="true" @click=${u => this.onClick(u)} @dragstart=${u => this.onDrag(u)}>
				${t.map(({ level: u, text: o }) => m`<li class="${e("item")} m_level_${u}"><span class="${e("link")}">${o}</span></li>`)}
			</ul>`; else {
			const u = this.editor.params.placeholders.contents || "Table of Contents", o = this.editor.params.placeholders.contents_icon; i = m`
			<div class="${e("empty")}" draggable="true" @click=${l => this.onClick(l)} @dragstart=${l => this.onDrag(l)}>
				${o ? m`<span class="${e("empty_icon")}">${se(o)}</span>` : ""}
				<span class="${e("empty_text")}">${u}</span>
			</div>`} const n = m`
		<span
			class="${e("cursor")}" contenteditable="true"
			@keydown=${u => this.onCursorKey(u)}
			@paste=${u => this.onCursorPaste(u)}
			@focus=${u => this.onFocus(u)}
			@blur=${u => this.onBlur(u)}
		>
		</span>`; return k(m`${s || i}${n}`, this.el), this.el.classList.toggle("m_empty", !!i), this.el
	} focus(t) { const e = this.el.querySelector("." + this.class("cursor")); !e || (t && t.preventDefault(), e.focus(), this.onFocus()) } onClick(t) { this.focus(t) } onCursorKey(t) { t.ctrlKey || t.metaKey || t.preventDefault() } onCursorPaste(t) { t.stopPropagation(), t.preventDefault() } onDrag(t) { E(this.editor.target).intersectsNode(t.currentTarget) || C(this.editor.target, { key: this.id, pos: 0 }) } onFocus() { this.el.classList.add("m_focus"), this.inFocus = !0, this.editor.setRange({ key: `${this.id}`, pos: 0 }) } onBlur() { this.inFocus && (this.el.classList.remove("m_focus"), this.inFocus = !1) }
} var we = N(ye); const ve = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])+/gu; class Ce extends S { static get tag() { return "div" } static get class() { return "tags" } get tags() { return this._tags || [] } set tags(t) { this._tags = t } get allowedAttributes() { return ["align", "anchor"] } create(t) { return super.create(t) } update(t) { this.attributes !== t.attributes && this.updateAttributes(t.attributes), this.item !== t && (this.item = t, this.render()) } render() { const t = [], e = []; (this.item.value || []).forEach(s => { const i = new Ee(this.editor, this.model, s); t.push(i.wrap || i.el), e.push(i) }), k(m`${t}`, this.el), this.tags = e } onClick(t) { if (t.target === this.el) return t.preventDefault(), this.focus(), !0 } focus() { const t = this.tags.slice(-1)[0]; !this.el.querySelector(":focus") && t && t.focus() } } class Ee extends Rt { static get tag() { return "span" } static get class() { return "tag" } create(t) { const e = super.create(t), s = this.wrap = document.createElement("div"); return s.classList.add(this.class("wrap")), s.append(e), s.addEventListener("click", i => { i.target === s && this.focus(null, 0) }, !1), e } focus(t, e) { const s = this.id; e = e != null ? e : this.el.textContent.length, C(this.editor.target, { pos: e, key: s }) } space(t) { this.break(t) } enter() { this.break() } backspace({ from: t, collapsed: e }) { if (t.pos !== 0 || !e) return !0; const s = this.model.getPrevById(parseInt(this.item.id)); return s && s.name !== "tag" ? (this.model.convert("p", this.item.id), !1) : !0 } break(t) { const e = this.item.id; let s; if (t) { const i = t.from ? t.from.pos : this.el.textContent.length; s = this.editor.model.insertBreak({ key: e, pos: i }) } else { const i = this.model.getParentById(e); s = this.model.insertAfter("p", i.id) } s && this.editor.setRange({ key: s, pos: 0 }) } update(t) { !super.update(t) || setTimeout(() => this.onUpdate(), 0) } onUpdate() { const t = this.item.value, e = t.match(/(\s*#|,\s+#?)/); if (e) { const i = this.item.id, n = e.index; this.model.insertBreak({ key: i, pos: n }, { key: i, pos: n + e[0].length }, !1); return } const s = `${t}x`.toLowerCase().match(ve).join("_").replace(/x$/, "").slice(0, 30); if (s !== t) { const i = this.editor.getModelRange(); setTimeout(() => { const n = this.model.replaceText({ key: this.id, pos: 0 }, { key: this.id, pos: t.length }, s, !1); n && i && i.to.pos === 0 && C(this.editor.target, n.to) }, 0) } } } var Fe = N(Ce); const Ae = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, zt = /[&<>"']/g, xe = RegExp(zt.source); function _e(r) { return r && xe.test(r) ? r.replace(zt, t => Ae[t]) : r || "" } class be extends S {
	get allowedAttributes() { return ["lang", "anchor"] } constructor(...t) { if (super(...t), this.editor.modules.highlight) return; const e = () => { const s = this.editor.modules.highlight; s && this.prevValue && this.render(this.prevValue), s && this.editor.off("register", e) }; this.editor.on("register", e) } update(t) { const e = this.getText(t), s = this.prevValue, i = this.attributes.lang; return this.attributes !== t.attributes && this.updateAttributes(t.attributes), e !== s || t.attributes.lang !== i ? (this.item = t, this.prevValue = e, this.render(e), !0) : !1 } render(t) {
		let e = b(t); e.slice(-1) === `
`&& (e += `
`); const s = this.attributes.lang, i = this.editor.modules.highlight; s && i ? this.el.innerHTML = i.render(e, s) : this.el.innerHTML = _e(e), this.el.spellcheck = !1
	} getText(t) { return (tt(t) || []).map(s => s.text).join("") } enter(t) {
		let e, s = !1; const i = this.item, n = this.getText(i), u = n.match(/^\n+/), o = n.match(/\n+$/), l = n.slice(0, t.from.pos).match(/\n+$/), a = n.slice(t.to.pos).match(/^\n+/), c = u ? u[0].length : 0, d = o ? o[0].length : 0, h = l ? l[0].length : 0, p = a ? a[0].length : 0; if (c > 0 && t.to.pos <= c ? s = "start" : d > 0 && t.from.pos >= n.length ? s = "end" : h + p > 2 && (s = "center"), s) { let f = !1, g = !1; if (!t.collapsed) { const $ = this.model.removeText(t.from, t.to, !1); t.from = { ...$ }, t.to = { ...$ } } const y = { key: t.from.key }, w = { ...t.to }; s === "start" ? (y.pos = 0, f = !0, g = !0) : s === "end" ? (y.pos = n.length - d, w.pos = n.length) : (y.pos = t.from.pos - h, w.pos = t.from.pos + p, g = !0), e = this.model.insertBreak(y, w, !f && !g), e && (f && this.model.convert("p", parseInt(y.key), null, !g), g && (this.model.convert("pre", e, null, !1), this.model.assign(`${e}.@`, { ...this.attributes })), this.editor.setRange({ key: e, pos: 0 })) } else {
			let g = `
${this.getPreIndent(i.value, t.from.pos)}`; const y = this.model.replaceText(t.from, t.to, g); this.editor.setRange(y.to)
		}
	} backspace(t) { if (t.collapsed && t.from.pos !== 0) { const e = this.indentOnEndOfEmptyLine(this.item.value, t.from.pos); if (e > 0) { const s = this.model.removeText({ ...t.from, pos: t.from.pos - e }, t.from); return this.editor.setRange(s), !1 } } return !0 } indentOnEndOfEmptyLine(t, e) {
		const s = b(t); if (!s[e] || s[e] === `
`) { const i = s.slice(0, e).match(/\s*$/)[0].replace(/^\n+/, "").length, u = (e - i < 0 ? "" : this.getPreIndent(t, e - i)).length; if (i > 0 && i === u) return i } return 0
	} getPreIndent(t, e) {
		const s = b(t).split(`
`); let i = 0, n = 0; for (; n < s.length && i < e && (i += s[n].length + 1, !(i >= e));)n++; return s[n].trim() ? s[n].match(/(\s*).*/)[1] : ""
	}
} var Be = N(be); class ke extends S { static get tag() { return "hr" } } var $e = N(ke); class Te { constructor() { Object.defineProperty(this, "_listeners", { value: {} }) } on(t, e, s, i) { typeof s != "object" && (s = {}), this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push({ callback: e, context: i, options: s }) } once(t, e, s, i) { return s || (s = {}), s.once = !0, this.callback(t, e, i, s) } off(t, e) { if (t) { if (this._listeners[t]) { const s = []; this._listeners[t].forEach(i => { if (!e || i.callback === e) return s.push(i) }), this._listeners[t] = s } } else Object.keys(this._listeners).forEach(s => { delete this._listeners[s] }); return this } emit(t, ...e) { if (!!this._listeners[t]) return this._listeners[t].forEach(({ callback: s, context: i, options: n }) => { n.once && this.off(t, s), s.apply(i || this, e) }), this } trigger(...t) { return this.emit.apply(this, t), this } } class W { constructor() { this._events = {} } on(t, e, s, i = !1) { return this._events[t] || (this._events[t] = []), this._events[t].push({ target: e, fn: s }), e.addEventListener(t, s, i), this } once(t, e, s, i = !1) { const n = u => { this.off(t, e, n), s(u) }; return i || (i = {}), i.once = !0, this.on(t, e, n, i) } off(t, e, s) { if (t) { var i = []; this._events[t].forEach(n => { var u = !0; e && e === n.target ? s === n.fn ? (e.removeEventListener(t, s), u = !1) : s || (e.removeEventListener(t, n.fn), u = !1) : e || (n.target.removeEventListener(t, n.fn), u = !1), u && i.push(n) }), this._events[t] = i } else for (let n in this._events) this._events[n].forEach(u => { u.target.removeEventListener(n, u.fn) }), delete this._events[n]; return this } } function Ie(r, t, e) { return new U(r, t, e).el } class U {
	static get tag() { return "figure" } static get class() { return "w-figure" } get type() { return "image" } get item() { return this._item } set item(t) { this._item = this._normalizeItem(t) } get caption() { return this._caption || null } set caption(t) { this._caption = t } get props() { return this.getProps() } set props(t) { this.setProps(t) } get id() { return this.item.id } constructor(t, e, s) { this.editor = t, this.model = e, this.item = null, this.class = J(this.constructor.class), this.inFocus = !1, this.create(s).update(s) } create(t) { const e = document.createElement(this.constructor.tag); return e.setAttribute("node-id", t.id || this.id), t.value.anchor && e.setAttribute("data-anchor", t.value.anchor), e.className = this.class(), e.contentEditable = !1, e.update = s => this.update(s), e.widget = this, this.el = e, this.el } update(t) { this.item !== t && (this.item = t, this.render()) } updateProps(t, e = !0) { this.model.assign(this.item.id, t, e) } setProps(t) { const e = this.item; this.update({ ...e, value: { ...e.value, ...t } }) } getProps() { const t = { ...this.item.value }, e = this.el.querySelector(`.${this.class("image")}`); return !e || !e.naturalWidth || t.width && t.height && t.naturalWidth && t.naturalHeight || (t.naturalWidth || (t.naturalWidth = e.naturalWidth), t.naturalHeight || (t.naturalHeight = e.naturalHeight), t.width || (t.height ? t.width = e.width * t.height / e.height : t.width = e.width), t.height || (t.height = t.width * e.height / e.width)), t } getResizeMode() { switch (this.item.value.size) { case "custom": return "ratio"; default: return !1 } } render() {
		const t = this.getProps(), e = this.class, s = t.src ? t.src : this.dummySrc(), i = !(s.indexOf("data:") === 0 || s.indexOf("blob:") === 0), n = this.renderTools(), u = this.renderCursor(), o = this.editor.params.options.media_caption ? this.renderCaption("caption_image") : "", l = this.renderResize(); let a = t.naturalWidth; switch (t.size) { case "retina": a = t.naturalWidth ? t.naturalWidth / 2 : a; break; case "column": a = null; break; case "custom": a = t.width; break }const c = m`
		<div class="${e("wrap")}" @click=${d => this.onClick(d)}>
			<img
				class="${e("image")}"
				src=${s}
				width=${a || ""}
				@load=${d => this.onLoad(d)}
				@dragstart=${d => this.onDrag(d)}
			/>
			<div class="${e("loading")}"></div>
			${l}
		</div>`; return k(m`${n}${c}${u}${o}`, this.el), this.el.classList.toggle("m_column", t.size === "column"), this.el.classList.toggle("m_custom", t.size === "custom"), this.el.classList.toggle("m_loading", !i), this.el
	} renderTools() { return this.editor.modules.mediaToolbar ? this.editor.modules.mediaToolbar.renderTools(this, this.type, this.item.value) : "" } renderCursor() {
		const t = this.class; return m`
		<span
			class="${t("cursor")}" contenteditable="true"
			@keydown=${e => this.onCursorKey(e)}
			@paste=${e => this.onCursorPaste(e)}
			@focus=${e => this.onFocus(e)}
			@blur=${e => this.onBlur(e)}
		>
		</span>`} renderCaption(t = "caption") {
		if (!this.editor.params.options.media_caption) return ""; let e; const s = this.class, i = this.editor.params.placeholders[t] || "Caption"; return this.caption ? (this.caption.update(this.item), e = this.caption.el) : (this.caption = new Lt(this.editor, this.model, this.item, "div", "caption"), e = this.caption.el, e.contentEditable = !0, e.setAttribute("placeholder", i), e.classList.add(s("caption_wrap"))), m`
		<figcaption
			class="${s("caption")} ${e.textContent.trim() ? "" : "m_empty"}"
			data-align="${this.props.captionAlign || null}"
			spellcheck="false"
			autocomplete="false"
			@input=${n => this.onCaptionInput(n)}
			@click=${() => e.focus()}
		>${e}</figcaption>`
	} renderResize() { const t = this.getResizeMode(), e = this.class, s = { width: ["x", "xy"], height: ["y", "xy"], ratio: ["x", "y", "xy"], all: ["x", "y", "xy"] }; if (t && s[t]) { const i = s[t].includes("x") ? m`<div class="${e("resize", "x")}"  @mousedown=${o => this.onStartResize(o, "x")} @touchstart=${o => this.onStartResize(o, "x")}></div>` : "", n = s[t].includes("y") ? m`<div class="${e("resize", "y")}"  @mousedown=${o => this.onStartResize(o, "y")} @touchstart=${o => this.onStartResize(o, "y")}></div>` : "", u = s[t].includes("xy") ? m`<div class="${e("resize", "xy")}" @mousedown=${o => this.onStartResize(o, "xy")} @touchstart=${o => this.onStartResize(o, "xy")}></div>` : ""; return m`${i}${n}${u}` } else return "" } dummySrc() { return `data:image/svg+xml;base64,${btoa('<svg width="800" height="600" viewBox="0 0 800 600" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="800" height="600" rx="7" fill="#EEEEEE"/></svg>')}` } focus(t) { const e = this.el.querySelector("." + this.class("cursor")); !e || (t && t.preventDefault(), e.focus(), this.onFocus()) } onClick(t) { this.focus(t) } onCursorKey(t) { t.ctrlKey || t.metaKey || t.preventDefault() } onCursorPaste(t) { t.stopPropagation(), t.preventDefault() } onDrag(t) { E(this.editor.target).intersectsNode(t.currentTarget) || C(this.editor.target, { key: this.id, pos: 0 }) } onFocus() { this.el.classList.add("m_focus"), this.inFocus = !0, this.editor.setRange({ key: `${this.id}`, pos: 0 }) } onBlur() { this.inFocus && (this.el.classList.remove("m_focus"), this.inFocus = !1) } onLoad() { const t = this.getProps(); this.setProps(t), this.updateProps(t, !1) } onCaptionInput(t) { t.target.textContent.trim().length === 0 ? t.target.classList.add("m_empty") : t.target.classList.remove("m_empty") } toolsToggleSelect(t, e, s) { this.editor.modules.mediaToolbar && this.editor.modules.mediaToolbar.toggleSelect(t, this, e, s) } onStartResize(t, e) { const s = new W, i = this.item, n = this.getProps(), u = n.size || "custom", o = this.getResizeMode() || null; let l = { ...n }; const a = d => { l = this._resize(n, t, d, o, e), this.update({ ...i, value: { ...n, ...l, size: u } }) }, c = () => { s.off(), this._inResize = !1, this.el.classList.remove("m_resize"), this.updateProps({ ...n, ...l, size: u }) }; s.on("mousemove", document, a), s.on("touchmove", document, a), s.on("mouseup", document, c), s.on("touchend", document, c), s.on("touchcancel", document, c), this.el.classList.add("m_resize"), this._inResize = !0, this.toolsToggleSelect(null, null, !1) } _resize(t, e, s, i, n) { if (!i) return {}; s.preventDefault(); const u = e.touches ? e.touches[0] : e; if (!u) return {}; const o = s.touches ? s.touches[0] : s; if (!o) return {}; const l = 15, a = n.includes("x") ? o.pageX - u.pageX : 0, c = n.includes("y") ? o.pageY - u.pageY : 0; let d = Math.min(Math.max(l, t.width + a), t.naturalWidth || 1 / 0), h = Math.min(Math.max(l, t.height + c), t.naturalHeight || 1 / 0); if (i === "ratio") { let p = d / t.width, f = h / t.height, g = 1; a && c ? g = Math.max(p, f) : a ? g = p : c && (g = f), d = t.width * g, h = t.height * g } switch (i) { case "width": return { width: d }; case "height": return { height: h }; default: return { width: d, height: h } } } _normalizeItem(t) { return t && (t.value.caption || (t.value.caption = []), typeof t.value.width == "string" && (t.value.width = parseInt(t.value.width), isNaN(t.value.width) && delete t.value.width), typeof t.value.height == "string" && (t.value.height = parseInt(t.value.height), isNaN(t.value.height) && delete t.value.height), t.value.size || (t.value.size = "original", t.value.width && t.value.naturalWidth && (t.value.width * 2 === t.value.naturalWidth ? t.value.size = "retina" : t.value.width !== t.value.naturalWidth && (t.value.size = "custom"))), t) }
} function Ne(r, t, e) { return new Se(r, t, e).el } class Se extends U {
	get type() { return "video" } _normalizeItem(t) { if (!t) return t; t = super._normalizeItem(t); const e = t.value; return e.autoplay == null && (e.autoplay = !1), e.loop == null && (e.loop = !1), e.mute == null && (e.mute = !1), e.controls == null && (e.controls = !0), t.value = e, t } getProps() { const t = { ...this.item.value }, e = this.el.querySelector(`.${this.class("video")}`); if (!e || !e.videoWidth || t.width && t.height && t.naturalWidth && t.naturalHeight) return t; t.naturalWidth || (t.naturalWidth = e.videoWidth), t.naturalHeight || (t.naturalHeight = e.videoHeight); let s = e.width || e.videoWidth, i = e.height || e.videoHeight; return t.width || (t.height ? t.width = s * t.height / i : t.width = s), !t.height && i && (t.height = t.width * i / s), t } render() {
		const t = this.getProps(), e = this.class, s = t.src ? t.src : this.dummySrc(), i = !(s.indexOf("data") === 0 || s.indexOf("blob") === 0), n = this.renderTools(), u = this.renderCursor(), o = this.renderCaption(), l = this.renderResize(); let a = t.naturalWidth; switch (t.size) { case "column": a = null; break; case "custom": a = t.width; break }const c = m`
		<div class="${e("wrap")}" @click=${h => this.onClick(h)}>
			<video
				class="${e("video")}"
				preload=true
				.src=${s}
				.autoplay=${t.autoplay}
				.playsinline=${t.autoplay}
				.loop=${t.loop}
				.muted=${t.mute}
				.controls=${t.controls}
				width=${a || ""}
				@loadedmetadata=${h => this.onLoad(h)}
				@dragstart=${h => this.onDrag(h)}
			></video>
			<div class="${e("loading")}"></div>
			<div class="${e("preventer")}" draggable="true"></div>
			${l}
		</div>`; k(m`${n}${c}${u}${o}`, this.el); const d = this.el.querySelector(`.${e("video")}`); return t.autoplay ? d.play() : d.pause(), this.el.classList.toggle("m_column", t.size === "column"), this.el.classList.toggle("m_custom", t.size === "custom"), this.el.classList.toggle("m_loading", !i), this.el
	}
} function Me(r, t, e) { return new v(r, t, e).el } class v extends U {
	get type() { return "iframe" } getProps() { const t = this.item.value, e = this.el.querySelector(`.${this.class("frame")}`); return !e || t.width || (t.width || (t.width = e.offsetWidth), t.height || (t.height = e.offsetHeight)), t } getResizeMode() { switch (this.item.value.size) { case "full_width": case "column": return "height"; case "16x9": return "ratio"; case "custom": return "all"; default: return !1 } } _normalizeItem(t) { return t && (t.value.caption || (t.value.caption = []), typeof t.value.width == "string" && (t.value.width = parseInt(t.value.width), isNaN(t.value.width) && delete t.value.width), typeof t.value.height == "string" && (t.value.height = parseInt(t.value.height), isNaN(t.value.height) && delete t.value.height), t.value.size || (t.value.size = "column", t.value.width && (t.value.size = "custom")), t) } render() {
		const t = this.getProps(), e = this.class, s = this.getUrl, i = this.getName(), n = this.type, u = this.renderTools(), o = this.renderCursor(), l = this.renderCaption(), a = this.renderResize(); let { width: c, height: d } = t; c && (c += "px"), d && (d += "px"); let h = { class: [e("frame_spacer")], width: c, height: d }; switch (t.size) { case "full_width": h.width = "5000px"; break; case "column": h.width = "5000px"; break; case "16x9": h.viewBox = "0 0 16 9", delete h.height; break }let p = Y`<svg version="1.1"
			class=${h.class.join(" ")}
			viewBox=${h.viewBox || ""}
			width=${h.width || ""}
			height=${h.height || ""}
		></svg>`, f = m`
		<div class="${e("wrap")}" @click=${g => this.onClick(g)} @dragstart=${g => this.onDrag(g)}>
			${p}
			<iframe
				class="${e("frame")} embed-${n}"
				name=${i}
				src=${s(t)}
				frameborder="0"
				scrolling=${t.noscroll ? "no" : null}
				allow="accelerometer; autoplay; encrypted-media; clipboard-write; gyroscope; picture-in-picture; web-share"
				?allowfullscreen=${!0}
			></iframe>
			<div class="${e("preventer")}" draggable="true"></div>
			${a}
		</div>`; return k(m`${u}${f}${o}${l}`, this.el), this.el.classList.toggle("m_column", t.size === "column"), this.el.classList.toggle("m_custom", t.size === "custom"), this.el
	} getUrl(t) { return t.src || "" } getName() { return `${this.type}_${this.item.id}` }
} function Pe(r, t, e) { return new Wt(r, t, e).el } class Wt extends v {
	get type() { return "youtube" } _normalizeItem(t) { if (!t) return t; t = super._normalizeItem(t); const e = t.value; if (!t.value.src) return t; const i = new URL(e.src).searchParams; if (e.autoplay == null && (e.autoplay = i.has("autoplay") ? i.get("autoplay") === "true" : !1), e.loop == null && (e.loop = i.has("loop") ? i.get("loop") === "true" : !1), e.mute == null && (e.mute = i.has("mute") ? i.get("mute") === "true" : !1), e.showinfo == null && (e.showinfo = i.has("showinfo") ? i.get("showinfo") === "true" : !0), i.has("start")) { let n = parseInt(i.get("start")); isNaN(n) || (e.start = n) } return t.value = e, t } getResizeMode() { switch (this.item.value.size) { case "custom": return "ratio"; default: return !1 } } render() {
		const t = this.getProps(), e = this.class, s = this.type, i = this.getUrl, n = this.renderTools(), u = this.renderCursor(), o = this.renderCaption(), l = this.renderResize(); let a = { class: [e("frame_spacer")], width: t.width }; switch (a.width && (a.width += "px"), t.size) { case "full_width": a.class.push("m_fullwidth"), a.width = "5000px"; break; case "column": a.width = "5000px"; break }let c = Y`<svg version="1.1"
			class=${a.class.join(" ")}
			viewBox='0 0 16 9'
			width=${a.width || ""}
			height=${""}
		></svg>`, d = m`
		<div class="${e("wrap")}" @click=${h => this.onClick(h)} @dragstart=${h => this.onDrag(h)}>
			${c}
			<iframe
				class="${e("frame")} embed-${s}"
				src=${i(t)}
				frameborder="0"
				allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
				?allowfullscreen=${!0}
			></iframe>
			<div class="${e("preventer")}" draggable="true"></div>
			${l}
		</div>`; return k(m`${n}${d}${u}${o}`, this.el), this.el.classList.toggle("m_column", t.size === "column"), this.el.classList.toggle("m_custom", t.size === "custom"), this.el
	} getUrl(t) { if (!t.src) return ""; let e = t.src.match(/^((\w+:)?\/\/)?(?:www\.|m\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|live\/|shorts\/|v\/|watch\?v=|watch\?.+&v=))([^#&?\s\n]+)/i); if (e) { let s = e.slice(-1), i = []; const n = o => o ? 1 : 0, u = o => !!o; return t.autoplay != null && i.push(`autoplay=${n(t.autoplay)}`), t.loop != null && i.push(`loop=${n(t.loop)}`), t.mute != null && i.push(`mute=${n(t.mute)}`), t.showinfo != null && i.push(`showinfo=${n(t.showinfo)}`), t.start != null && i.push(`start=${t.start}`), u(t.loop) && i.push(`playlist=${s}`), `https://www.youtube.com/embed/${s}${i.length > 0 ? "?" + i.join("&") : ""}` } return "" }
} function Le(r, t, e) { return new Re(r, t, e).el } class Re extends Wt { get type() { return "vimeo" } _normalizeItem(t) { if (!t) return t; t = super._normalizeItem(t); const e = t.value; if (!t.value.src) return t; const i = new URL(e.src).searchParams; return e.autoplay == null && (e.autoplay = i.has("autoplay") ? i.get("autoplay") === "true" : !1), e.loop == null && (e.loop = i.has("loop") ? i.get("loop") === "true" : !1), e.mute == null && (e.mute = i.has("muted") ? i.get("muted") === "true" : !1), e.showinfo == null && (e.showinfo = i.has("title") ? i.get("title") === "true" : !0), t.value = e, t } getUrl(t) { if (!t.src) return ""; let e = t.src.match(/^(?:(?:\w+:)?\/\/)?(?:\w+\.)?vimeo\..*?\/(\d+)(?:\/([0-9a-z]+))?/i); if (e) { let s = e[1], i = []; return e[2] && i.push(`h=${e[2]}`), t.autoplay != null && i.push(`autoplay=${!!t.autoplay}`), t.loop != null && i.push(`loop=${!!t.loop}`), t.mute != null && i.push(`muted=${!!t.mute}`), t.showinfo != null && i.push(`title=${!!t.showinfo}`), `https://player.vimeo.com/video/${s}/${i.length > 0 ? "?" + i.join("&") : ""}` } return "" } } function ze(r, t, e) { return new We(r, t, e).el } class We extends v { get type() { return "twitter" } _normalizeItem(t) { return !t || (t = super._normalizeItem(t), !t.value.src) || (t.value.twitterCards == null && (t.value.twitterCards = !0), t.value.size = "custom", t.value.noscroll = !0), t } getResizeMode() { return !1 } render() { this.destroy(); const t = this.class, e = super.render(), s = this.el.querySelector(`.${t("frame")}`), i = n => { if (n.source === s.contentWindow) try { let u = typeof n.data == "string" ? JSON.parse(n.data) : n.data; if (u = u["twttr.embed"] ? u["twttr.embed"] : u, u.method === "twttr.private.resize" && u.params && u.params[0] && u.params[0].height) { let { width: o, height: l } = u.params[0]; l += 2, this.updateProps({ width: o, height: l }) } } catch { } }; return window.addEventListener("message", i), this._unbindMessage = () => { window.removeEventListener("message", i) }, e } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/(?:www\.|mobile\.)?twitter\.com\/(?:.+)\/status\/(\d+)/i); return e ? `https://platform.twitter.com/embed/Tweet.html?id=${e[1]}&hideCard=${!t.twitterCards}` : "" } destroy() { this._unbindMessage && this._unbindMessage() } } function Oe(r, t, e) { return new Ve(r, t, e).el } class Ve extends v {
	get type() { return "facebook" } getResizeMode() { return !1 } _normalizeItem(t) { return !t || (t = super._normalizeItem(t), !t.value.src) || t.value.showText == null && (t.value.showText = !1), t } render() {
		const t = this.class, e = this.type, s = this.getProps(), i = this.renderTools(), n = this.renderCursor(), u = this.renderCaption(), o = m`
		<div class="${t("wrap")}" @click=${l => this.onClick(l)} @dragstart=${l => this.onDrag(l)}>
			<div class="${t("widget")} embed-${e} m_container">
				<div class="fb-post" data-href="${s.src}" data-width="500" data-show-text="${s.showText}"></div>
			</div>
			<div class="${t("preventer")}" draggable="true"></div>
		</div>`; return k(m`${i}${o}${n}${u}`, this.el), window.FB && setTimeout(() => window.FB.XFBML.parse(), 1), this.el
	}
} function Ue(r, t, e) { return new je(r, t, e).el } class je extends v { get type() { return "tiktok" } getResizeMode() { return !1 } render() { this.destroy(); const t = this.class, e = super.render(), s = this.el.querySelector(`.${t("frame")}`), i = n => { if (n.source === s.contentWindow) try { const u = JSON.parse(n.data); u.signalSource === this.getName() && u.height && this.updateProps({ height: u.height }) } catch { } }; return window.addEventListener("message", i), this._unbindMessage = () => { window.removeEventListener("message", i) }, e } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/tiktok\.com\/(?:.*?)\/(\d+)/i); return e ? `https://www.tiktok.com/embed/v2/${e[1]}` : "" } getName() { return `__tt_embed__v${this.item.id}` } destroy() { this._unbindMessage && this._unbindMessage() } } function He(r, t, e) { return new Ke(r, t, e).el } const ft = /^(?:https?:)?(?:\/\/)?(?:t\.me|telegram\.me)\/(?:@?([a-z0-9_-]+))\/(\d+)/i; class Ke extends v { get type() { return "telegram" } _normalizeItem(t) { if (!t || (t = super._normalizeItem(t), !t.value.src)) return t; if (t.value.userpic == null && (t.value.userpic = !0, (t.value.src || "").match(ft) && window.URL)) { const i = new URL(t.value.src).searchParams; t.value.userpic = i.has("userpic") ? i.get("userpic") === "true" || i.get("userpic") === "1" : !0 } return t.value.noscroll = !0, t } getResizeMode() { return !1 } render() { this.destroy(); const t = this.class, e = super.render(), s = this.el.querySelector(`.${t("frame")}`), i = n => { if (n.source === s.contentWindow) try { const u = JSON.parse(n.data); u.event === "resize" && u.height && this.updateProps({ height: u.height }) } catch { } }; return window.addEventListener("message", i), this._unbindMessage = () => { window.removeEventListener("message", i) }, e } getUrl(t) { if (!t.src) return ""; const e = t.src.match(ft); if (e) { const s = ["embed=1"]; return t.userpic != null && s.push(`userpic=${t.userpic === "true" || t.userpic === !0 ? "1" : "0"}`), `https://t.me/${e[1]}/${e[2]}?${s.join("&")}` } return "" } destroy() { this._unbindMessage && this._unbindMessage() } } function qe(r, t, e) { return new Xe(r, t, e).el } class Xe extends v { get type() { return "instagram" } getResizeMode() { return !1 } _normalizeItem(t) { return !t || (t = super._normalizeItem(t), !t.value.src) || t.value.showText == null && (t.value.showText = !1), t } render() { this.destroy(); const t = this.class, e = super.render(), s = this.el.querySelector(`.${t("frame")}`), i = n => { if (n.source === s.contentWindow) try { const u = JSON.parse(n.data); u.type === "MEASURE" && u.details && u.details.height && this.updateProps({ height: u.details.height }) } catch { } }; return window.addEventListener("message", i), this._unbindMessage = () => { window.removeEventListener("message", i) }, e } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/(?:instagr\.am|instagram\.com)\/(p|tv)\/([a-z0-9_-]+)\/?/i); if (e) { let s = `https://www.instagram.com/${e[1]}/${e[2]}/embed/`; return t.showText && (s += "captioned/"), s } return "" } destroy() { this._unbindMessage && this._unbindMessage() } } function Ye(r, t, e) { return new Je(r, t, e).el } class Je extends v { get type() { return "figma" } _normalizeItem(t) { return t && (t = super._normalizeItem(t), t.value.height = t.value.height || 360, t) } getUrl(t) { return t.src ? t.src.match(/figma\.com\/file\/.+/i) ? `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(t.src)}` : t.src.match(/figma\.com\/embed/i) ? t.src : "" : "" } } function Ze(r, t, e) { return new Ot(r, t, e).el } class Ot extends v { get type() { return "codepen" } _normalizeItem(t) { return t && (t = super._normalizeItem(t), t.value.height = t.value.height || 300, t) } getResizeMode() { const t = super.getResizeMode(); return t === "ratio" ? "all" : t } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/codepen\.io\/(?:(.+)\/)?(?:pen|embed)\/(.+)/i); if (e) { const s = []; return t.js && s.push("js"), t.css && s.push("css"), t.html && s.push("html"), t.result && s.push("result"), `https://codepen.io/${e[1] ? e[1] + "/" : ""}embed/${e[2]}${s.length > 0 ? "?default-tab=" + s.join(",") : ""}` } return "" } } function Ge(r, t, e) { return new Qe(r, t, e).el } class Qe extends Ot { get type() { return "jsfiddle" } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/jsfiddle\.net\/([a-z0-9_-]+)/i); if (e) { const s = ["js", "css", "html", "result"]; return t.js || s.splice(s.indexOf("js"), 1), t.css || s.splice(s.indexOf("css"), 1), t.html || s.splice(s.indexOf("html"), 1), t.result || s.splice(s.indexOf("result"), 1), `https://jsfiddle.net/${e[1]}/embedded/${s.length > 0 ? s.join(",") + "/" : ""}` } return "" } } function ts(r, t, e) { return new es(r, t, e).el } class es extends U {
	get type() { return "gist" } getProps() { return this.item.value } getResizeMode() { return !1 } _normalizeItem(t) { return t && (t.value.caption || (t.value.caption = []), t) } render() {
		const t = this.class, e = this.type, s = this.getProps(), i = this.getUrl(s), n = this.renderTools(), u = this.renderCursor(), o = this.renderCaption(), l = `
			<body style="margin: 0; overflow: hidden;"><script src="${i}"><\/script></body>
		`; let a = { class: [t("frame_spacer")], width: "5000px", height: `${s.height || 100}px` }, c = f => Y`<svg version="1.1"
			class=${f.class.join(" ")}
			viewBox=${f.viewBox || ""}
			width=${f.width || ""}
			height=${f.height || ""}
		></svg>`; const d = () => m`
		<div class="${t("wrap")}" @click=${f => this.onClick(f)} @dragstart=${f => this.onDrag(f)}>
			${c(a)}
			<iframe
				class="${t("frame")} embed-${e}"
				frameborder="0"
				srcdoc="${l}"
			></iframe>
			<div class="${t("preventer")}" draggable="true"></div>
		</div>`; k((() => m`${n}${d()}${u}${o}`)(), this.el); const p = this.el.querySelector(`.${t("frame")}`); return p.addEventListener("load", () => { if (p.contentWindow) { const f = p.contentWindow.document.body.scrollHeight; f && this.updateProps({ height: f }) } }), this.el.classList.toggle("m_column", !0), this.el
	} getUrl(t) { if (!t.src) return ""; const e = t.src.match(/gist\.github\.com\/(.+?)\/([0-9a-f]+)/i); return e ? `https://gist.github.com/${e[1]}/${e[2]}.js` : "" }
} function ss(r, t, e) { return new is(r, t, e).el } const pt = /w\.soundcloud\.com\/player\/(.+)/i; class is extends v { get type() { return "soundcloud" } _normalizeItem(t) { if (!t) return t; if (t = super._normalizeItem(t), (t.value.src || "").match(pt) && window.URL) { const i = new URL(t.value.src).searchParams; t.value.autoplay == null && (t.value.autoplay = i.has("auto_play") ? i.get("auto_play") === "true" || i.get("auto_play") === "1" : !1), t.value.visual == null && (t.value.visual = i.has("visual") ? i.get("visual") === "true" || i.get("visual") === "1" : !1) } return t.value.height = t.value.height || 300, t } getUrl(t) { if (!t.src) return ""; if (t.src.match(/^((\w+:)?\/\/)(api\.|www\.)?soundcloud\.com\/(.+)/i)) { const i = []; return t.autoplay && i.push(`&auto_play=${!!t.autoplay}`), t.visual && i.push(`&visual=${!!t.visual}`), `https://w.soundcloud.com/player/?url=${encodeURIComponent(t.src)}${i.join("")}` } return t.src.match(pt) ? t.src : "" } } function rs(r, t, e) { return new ns(r, t, e).el } class ns extends v { get type() { return "anchorfm" } _normalizeItem(t) { return t && (t = super._normalizeItem(t), t.value.height = t.value.height || 102, t) } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/anchor.fm\/(.+?)\/(?:embed\/)?(.+)/i); return e ? `https://anchor.fm/${e[1]}/embed/${e[2]}` : "" } } function us(r, t, e) { return new os(r, t, e).el } const gt = /(?:embed\.)?podcasts\.apple\.com\/(.+)\/(id\d+)(?:(?:\?i=|\?.+&i=)(\d+))?/i; class os extends v { get type() { return "applepodcast" } _normalizeItem(t) { if (!t) return t; if (t = super._normalizeItem(t), !t.value.height && t.value.src) { const e = t.value.src.match(gt); t.value.height = e && e[3] ? 175 : 450 } return t } getUrl(t) { if (!t.src) return ""; const e = t.src.match(gt); return e ? `https://embed.podcasts.apple.com/${e[1]}/${e[2]}${e[3] ? "?i=" + e[3] : ""}` : "" } } function as(r, t, e) { return new ls(r, t, e).el } class ls extends v { get type() { return "spotify" } _normalizeItem(t) { return t && (t = super._normalizeItem(t), t.value.height = t.value.height || 380, t) } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/open\.spotify\.com\/(?:embed\/)?(\w+\/.+)/i); return e ? `https://open.spotify.com/embed/${e[1]}` : "" } } function cs(r, t, e) { return new ds(r, t, e).el } class ds extends v { get type() { return "yamaps" } _normalizeItem(t) { return t && (t = super._normalizeItem(t), t.value.height = t.value.height || 300, t) } getUrl(t) { if (!t.src) return ""; const e = t.src.match(/yandex\.(?:\w{2,3})\/(?:maps|web-maps|map-widget\/v1)\/(.+?\/.+)/i); return e ? `https://yandex.ru/map-widget/v1/${e[1]}` : "" } } function hs(r, t, e) { return new fs(r, t, e).el } const M = { iframe: /music\.yandex\.ru\/iframe\/?(?:#(\w*))?/i, playlist: /music\.yandex\.ru\/users\/(.+?)\/playlists\/(\d+)/i, default: /music\.yandex\.ru\/(.+?)\/(\d+)(?:\/(\w+)\/(\d+))?/i }; class fs extends v { get type() { return "yamusic" } _normalizeItem(t) { if (!t) return t; if (t = super._normalizeItem(t), !t.value.height && t.value.src) { let e = t.value.src.match(M.iframe); if (e && (t.value.height = e[1] === "track" ? 180 : 720), t.value.height || (e = t.value.src.match(M.playlist), e && (t.value.height = 720), t.value.height) || (e = t.value.src.match(M.default), e && (t.value.height = e[3] === "track" ? 180 : 720), t.value.height)) return t } return t } getUrl(t) { if (!t.src) return ""; if (t.src.match(M.iframe)) return t.src; const s = t.src.match(M.playlist); if (s) return `https://music.yandex.ru/iframe/#playlist/${s[1]}/${s[2]}`; const i = t.src.match(M.default); return i ? i[3] ? `https://music.yandex.ru/iframe/#${i[3]}/${i[4]}/${i[2]}` : `https://music.yandex.ru/iframe/#${i[1]}/${i[2]}` : "" } } const mt = { section: me, contents: we, tags: Fe, pre: Be, hr: $e, image: Ie, video: Ne, iframe: Me, youtube: Pe, vimeo: Le, twitter: ze, facebook: Oe, tiktok: Ue, telegram: He, instagram: qe, figma: Ye, codepen: Ze, jsfiddle: Ge, gist: ts, soundcloud: ss, anchorfm: rs, applepodcast: us, spotify: as, yamusic: hs, yamaps: cs }; function Dt(r, t, e) { if (e.name in mt) return mt[e.name](r, t, e); if (e.type === "formatted-string") return fe(r, t, e); if (e.type === "plain-string") return pe(r, t, e); const s = document.createElement(e.name); return s.setAttribute("node-id", e.id), e.attributes && e.attributes.anchor && s.setAttribute("data-anchor", e.attributes.anchor), s } class ps { constructor(t, e, s) { this.ctx = { rendered: {}, used: null }, this.editor = t, this.model = e, this.target = s } update(t) { const e = D(this.target); this.ctx.used = {}, this.renderBlock(this.target, t.value); const { rendered: s } = this.ctx; if (Object.keys(s).forEach(i => { s[i] && s[i].node.dispose && s[i].node.dispose() }), this.ctx.rendered = this.ctx.used, e) C(this.target, e.from, e.to); else { const i = G(this.target); if (i) { const n = i.nodeValue.length, u = document.createRange(); u.setStart(i, n), u.setEnd(i, n); const o = window.getSelection(); o.empty(), o.addRange(u) } } } destroy() { } renderBlock(t, e) { const s = this.model, i = this.editor, { rendered: n, used: u } = this.ctx, o = new Set(e.map(a => a.id)); let l = t.childNodes.length; for (; l--;) { const a = t.childNodes[l], c = a.nodeType === a.ELEMENT_NODE && Number(I(a)); (!c || !o.has(c)) && (a.widget && a.widget.destroy && a.widget.destroy(), t.removeChild(a)) } l = 0, e.forEach(a => { const { id: c } = a; let d; n[c] ? (d = u[c] = n[c], n[c] = null, t.childNodes[l] !== d.node && this.domInsert(d.node, t, t.childNodes[l]), d.item !== a && (d.item.name !== a.name ? d.node = this.renameItem(a, d.item, d.node) : d.node.update ? d.node.update(a, d.item) : d.node.updateAttributes && d.node.updateAttributes(a.attributes), d.item = a)) : (d = u[c] = { node: Dt(i, s, a), item: a }, this.domInsert(d.node, t, t.childNodes[l])), !d.node.update && a.type === "container" && this.renderBlock(d.node, a.value), l++ }) } domInsert(t, e, s) { return s ? e.insertBefore(t, s) : e.appendChild(t) } renameItem(t, e, s) { const i = Dt(this.editor, this.model, t), n = s.parentNode; return n.insertBefore(i, s), n.removeChild(s), i } } function gs(r, t) { if (r === t) return null; let e = 0, s = 0, i, n, u = Math.min(r.length, t.length); for (; e < u && (i = O(t, e), i === O(r, e));)e += i > 65535 ? 2 : 1; u -= e; const o = r.length - 1, l = t.length - 1; let a = 0; for (; s < u && (a = 0, i = t.charCodeAt(l - s), i >= 56320 && i <= 57343 && s + 1 < u && (n = t.charCodeAt(l - s), n >= 55296 && n <= 56319 && a++), O(r, o - s - a) === O(t, l - s - a));)s += 1 + a; return [e, s] } const O = String.prototype.codePointAt ? ms : Ds; function ms(r, t) { return r.codePointAt(t) } function Ds(r, t) { const e = r.charCodeAt(t); if (e >= 55296 && e <= 56319 && r.length > t + 1) { const s = r.charCodeAt(t + 1); if (s >= 56320 && s <= 57343) return (e - 55296) * 1024 + s - 56320 + 65536 } return e } function ys(r, t) { const e = gs(r, t); if (!e) return null; const [s, i] = e, n = r.slice(s, -i || r.length), u = t.slice(s, -i || t.length); return !n && u ? { action: "insert", text: u, pos: s } : n && !u ? { action: "remove", text: n, pos: s } : { action: "replace", text: u, oldText: n, pos: s } } class ws { constructor(t, e, s) { this.editor = t, this.model = e, this.target = s, this.inputHandled = !1, this.pendingUpdate = null, this.events = new W, this.delegateEvents() } delegateEvents() { this.events.on("selectionchange", document, () => this.onSelectionChange()), this.events.on("keypress", this.target, t => this.onKeypress(t)), this.events.on("input", this.target, t => this.onInput(t)) } undelegateEvents(t, e) { this.events.off(t, e) } destroy() { this.undelegateEvents(), this.inputHandled = !1, this.pendingUpdate = null } onSelectionChange() { const t = D(this.target); t && this.model.saveCaret(t) } onKeypress(t) { if (!t.defaultPrevented && vs(t)) { const e = D(this.target); if (e) { this.inputHandled = !0; const s = t.key; this.pendingUpdate ? this.pendingUpdate.text += s : this.pendingUpdate = { range: e, text: s } } } } onInput(t) { if (this.inputHandled && t.inputType === "insertText") return this.scheduleUpdate(); if (t.target.tagName === "INPUT") return; this.inputHandled = !1, this.pendingUpdate = null; const e = D(this.target); if (e && e.collapsed) { const s = e.from.key, i = this.model.getValue(s), n = x(this.target, s), u = ys(b(i), Z(n, b(i))); if (!u) return; const o = { key: s, pos: u.pos }, l = { key: s, pos: u.pos + (u.oldText || u.text).length }; switch (u.action) { case "insert": this.model.insertText(o, u.text); break; case "remove": this.model.removeText(o, l); break; case "replace": this.model.replaceText(o, l, u.text); break } } else e && console.warn("Unsupported input", e) } scheduleUpdate() { const t = () => { if (this.pendingUpdate) { const { range: e, text: s } = this.pendingUpdate; e.collapsed ? this.model.insertText(e.from, s) : this.model.replaceText(e.from, e.to, s), this.pendingUpdate = null } }; return requestAnimationFrame(() => t()), !0 } } function vs(r) { return r.key && r.charCode && !r.metaKey && !r.ctrlKey } class Cs { constructor() { this.shortcuts = {}, this.modifiers = this.constructor.modifiers } static get modifiers() { return { ctrl: 1, alt: 2, shift: 4, meta: 8, any: 64 } } register(t, e) { return Array.isArray(t) || (t = [t]), t.forEach(s => this.shortcuts[this.parse(s)] = e), this } unregister(t, e) { return Array.isArray(t) || (t = [t]), t.forEach(s => { const i = this.parse(s); this.shortcuts[i] && (!e || this.shortcuts[i] === e) && delete this.shortcuts[i] }), this } unregisterAll() { return this.shortcuts = {}, this } handle(t, ...e) { const s = this.maskFromEvent(t), i = this.getCode(t.code || t.key); let n = `${s}:${i}`; !this.shortcuts[n] && s && (n = `${this.modifiers.any}:${i}`); const u = this.shortcuts[n]; return u && u(t, ...e) !== !1 ? (t.preventDefault(), !0) : !1 } parse(t) { let e = 0, s = ""; return t.toLowerCase().split(/[+-]/g).forEach(i => { i === "cmd" && (i = navigator.platform === "MacIntel" ? "meta" : "ctrl"), i in this.modifiers ? e |= this.modifiers[i] : s = i }), `${e}:${s}` } maskFromEvent(t) { let e = 0; return t.altKey && (e |= this.modifiers.alt), t.shiftKey && (e |= this.modifiers.shift), t.ctrlKey && (e |= this.modifiers.ctrl), t.metaKey && (e |= this.modifiers.meta), e } getCode(t) { return t.replace(/^(Key|Digit|Numpad)/, "").toLowerCase() } } class Es {
	static get fragmentMIME() { return "teletype/fragment" } static get rangeMIME() { return "teletype/range" } constructor(t, e, s, i) { this.fragmentMIME = this.constructor.fragmentMIME, this.rangeMIME = this.constructor.rangeMIME, this.editor = t, this.model = e, this.target = s, this.container = i, this.shortcuts = new Cs, this.events = new W, this.delegateEvents(), this.addDefaultShortcuts() } delegateEvents() { return this.events.on("keydown", this.target, t => this.handle(t)), this.events.on("keyup", this.target, t => this.keyup(t)), this.events.on("copy", this.target, t => this.copy(t)), this.events.on("cut", this.target, t => this.cut(t)), this.events.on("paste", this.target, t => this.paste(t)), this } undelegateEvents(t = null, e = null) { return this.events.off(t, e), this } addDefaultShortcuts() { this.addShortcut("Enter", () => this.enter()), this.addShortcut("Space", () => this.space()), this.addShortcut("Shift+Enter", () => this.shiftEnter()), this.addShortcut("Backspace", () => this.backspace()), this.addShortcut("Shift+Backspace", () => this.backspace()), this.addShortcut("Delete", () => this.delete()), this.addShortcut("Cmd+Z", () => this.undo()), this.addShortcut(["Cmd+Y", "Cmd+Shift+Z"], () => this.redo()), this.addShortcut("Tab", () => this.indent()), this.addShortcut("Shift+Tab", () => this.dedent()), this.addShortcut("Cmd+B", () => this.toggleFormat("bold")), this.addShortcut("Cmd+I", () => this.toggleFormat("italic")), this.addShortcut("Cmd+U", () => this.toggleFormat("underline")), this.addShortcut("ArrowUp", t => this.arrow(t, "up")), this.addShortcut("ArrowDown", t => this.arrow(t, "down")), this.addShortcut("ArrowLeft", t => this.arrow(t, "left")), this.addShortcut("ArrowRight", t => this.arrow(t, "right")) } removeDefaultShortcuts(t) { return t || (t = ["Enter", "Shift+Enter", "Backspace", "Delete", "Cmd+Z", "Cmd+Y", "Cmd+Shift+Z", "Tab", "Shift+Tab", "Cmd+B", "Cmd+I", "Cmd+U"]), this.removeShortcut(t), this } addShortcut(t, e) { return this.shortcuts.register(t, e), this } removeShortcut(t, e) { return this.shortcuts.unregister(t, e), this } removeAllShortcuts() { return this.shortcuts.unregisterAll(), this } destroy() { this.removeAllShortcuts(), this.undelegateEvents() } focus() { const t = this.model.state.value[0]; t ? this.setRange(this.target, { key: t.id, pos: 0 }) : this.target.focus() } enter() { let t = D(this.target); if (t) { if (this.editor.modules.media) { if (this.editor.modules.media.parse(t)) return; t = D(this.target) } const e = this.model.getById(parseInt(t.from.key)); if (!e) return; const s = x(this.target, t.from.key); if (s && s.widget && s.widget.enter) s.widget.enter(t); else if (e.type === "block") { const i = this.model.insertAfter("p", e.id); i && this.setRange(this.target, { key: i, pos: 0 }) } else { const i = this.model.insertBreak(t.from, t.collapsed ? null : t.to); i && this.setRange(this.target, { key: i, pos: 0 }) } } } space() { const t = D(this.target); if (t) { const e = x(this.target, t.from.key); if ({ ...t.to }, e && e.widget && e.widget.space) return e.widget.space(t) } return !1 } shiftEnter() {
		const t = D(this.target); t && (this.model.replaceText(t.from, t.to, `
`), this.setRange(this.target, { ...t.to, pos: t.to.pos + 1 }))
	} backspace() { const t = D(this.target); if (t) { let { from: e, to: s, collapsed: i } = t; const n = this.model.getById(parseInt(e.key)), u = this.model.getById(parseInt(s.key)), o = this.model.getPrevById(parseInt(e.key)), l = n ? x(this.target, n.id) : null, a = o ? x(this.target, o.id) : null; if (l && l.widget && l.widget.backspace && !l.widget.backspace(t)) return; if (e.pos === 0 && i) { if (n.type === "block") { const c = this.model.removeNode(n.id), d = c ? { key: `${c}`, pos: 0 } : null; d && this.setRange(this.target, d) } else if (a && a.widget && a.widget.focus && (n.name === "p" || n.name === o.name)) (b(this.model.getValue(n.id)) || "").length === 0 && this.model.removeNode(n.id), a.widget.focus(); else if (n.name === "li") this.dedent(); else if (n.name !== "p") this.model.convert("p", n.id, u.id); else if (n.name === "p") { let c = this.model.joinWithPrevious(n.id); if (!c) { if (this.model.get("value.0.id") == n.id && this.model.get("value.1") && n.value.length === 0) { const d = this.model.removeNode(n.id); d && (c = { key: `${d}`, pos: 0 }) } this.editor.events && this.editor.events.trigger("focus:exit", "up") } c && this.setRange(this.target, c) } return !0 } else if (!i) this.removeSelectedText(e, s); else return !1 } } delete() { const t = D(this.target); if (t) { let { from: e, to: s, collapsed: i } = t; const n = e.key.split(".").length > 1, u = this.model.getById(parseInt(e.key)), o = x(this.target, e.key), l = () => { const a = this.model.getValue(e.key); return b(a) }; if (u && u.type === "block" && !n) return !0; if (o && e.pos === Z(o, l()).length && i && !n) { const a = this.model.joinWithNext(parseInt(e.key)); a && this.setRange(this.target, a) } else if (!i) this.removeSelectedText(e, s); else return !1 } } arrow(t, e) { const s = D(this.target); if (!s || !s.collapsed) return !1; const i = parseInt(s.from.key), n = this.model.getById(i); let u = null; const o = (l, a) => { const c = this.model[l](a); if (!c) return null; const d = parseInt(c.id); if (c.type === "formatted-string" || c.type === "plain-string") return { node: c, id: d }; const h = x(this.target, d); return h ? h.widget && typeof h.widget.focus == "function" ? { node: c, id: d, el: h } : o(l, d) : null }; switch (e) { case "down": case "right": u = o("getNextById", parseInt(s.from.key)); break; case "up": case "left": u = o("getPrevById", parseInt(s.from.key)); break }return u && (this._arrowAF && cancelAnimationFrame(this._arrowAF), this._arrowAF = requestAnimationFrame(() => { const l = D(this.target); if (!l || !l.collapsed) return !1; const a = parseInt(l.from.key), c = a !== i && a !== u.id, d = i === a && l.from.pos === s.from.pos && n.type === "block"; if (c || d) { const h = this.container.scrollTop; u.el && u.el.widget && typeof u.el.widget.focus == "function" ? u.el.widget.focus(t, l.from.pos) : C(this.target, { key: u.id, pos: l.from.pos }), this.focusOnRange(e, h) } })), !1 } removeSelectedText(t, e) { const s = this.model.removeText(t, e); this.setRange(this.target, s || t) } setRange(...t) { const e = this.container.scrollTop; C.apply(C, t), this.focusOnRange(null, e) } focusOnRange(t = null, e) { const s = E(this.target); if (!s) return; const i = 70, n = e != null ? e : this.container.scrollTop; let u = "commonAncestorContainer", o = "nearest"; switch (t) { case "up": case "left": case "prev": u = "startContainer"; break; case "down": case "right": case "next": u = "endContainer"; break }let l = s[u] || s.startContainer; l = l.nodeName === "#text" ? l.parentNode : l, l.scrollIntoView({ block: o }); const a = this.container.scrollTop; a !== n && (this.container.scrollTop += a > n ? i : -i); const c = l.getBoundingClientRect(); c.top < i && (this.container.scrollTop += c.top - i), window.innerHeight - c.top < i && (this.container.scrollTop += window.innerHeight - c.top) } toggleItem(t, e) { const s = E(this.target); if (!s) return !1; e || (e = K(this.model, s)); const i = T(s), n = e === t ? "p" : t; if (i) { if (i.from.key !== i.to.key && i.to.pos === 0) { const u = this.model.getPrevById(parseInt(i.to.key)); u && (i.to.key = u.id) } return this.model.convert(n, parseInt(i.from.key), parseInt(i.to.key)), !0 } } toggleFormat(t, e) { const s = E(this.target); if (!s) return !1; e == null && (e = !Mt(this.model, s).includes(t)); const i = T(s); if (i) return this.model.setFormat({ [t]: e }, i.from, i.to, !0), !0 } colorInjection(t) { const e = E(this.target); if (!e) return !1; const s = T(e); if (s) { let i = parseInt(s.from.key), n = parseInt(s.to.key), u = this.model.getById(i), o = u ? this.model.getParentById(u.id) : null; for (; u && o && o.type !== "document";)u = o, o = this.model.getParentById(u.id); return u && u.name === "section" && (i = u.id, n = null), this.model.colorInjection(t, i, n), !0 } } changeAlignment(t) { const e = E(this.target); if (!e) return !1; const s = T(e); if (s) { if (s.from.key !== s.to.key && s.to.pos === 0) { const i = this.model.getPrevById(parseInt(s.to.key)); i && (s.to.key = i.id) } return this.model.changeAlignment(t, s.from.key, s.to.key), !0 } } changeAttributes(t) { const e = E(this.target); if (!e) return !1; const s = T(e); if (s) return this.model.assign(`${s.from.key}.@`, t), !0 } copyFragment(t, e) { const s = D(this.target); if (s && !s.collapsed) { const i = window.getSelection(), n = K(this.model, E(this.target)); t.setData("text/plain", $t(i)), t.setData("text/html", Tt(i)); const u = e ? this.model.cut(s.from, s.to) : this.model.getFragment(s.from, s.to); return u.value.length > 0 && (!n && s.from.key === s.to.key && (u.value[0].name = "p", u.value[0].type = "formatted-string"), t.setData(this.fragmentMIME, JSON.stringify(u))), e && this.setRange(this.target, s.from), !0 } } appendFirstLine() { const t = this.model.get("value.0"); return t && t.type === "block" ? this.model.insertBefore("p", t.id) : null } indent() { const t = D(this.target); this.model.indent(Number(t.from.key), Number(t.to.key)) } dedent() { const t = D(this.target); this.model.dedent(Number(t.from.key), Number(t.to.key)) } undo() { const t = this.model.undo(); t && t.caret && this.setRange(this.target, t.caret.from, t.caret.to) } redo() { const t = this.model.redo(); if (t) { let e = t.range || t.caret; t.action === "removeText" && t.range && (e = { from: t.range.from, to: t.range.from }), e && this.setRange(this.target, e.from, e.to) } } handle(t) { return !!this.shortcuts.handle(t) } keyup(t) { this.editor.modules.autoFormat && this.editor.modules.autoFormat.onInput(t) } copy(t) { this.copyFragment(t.clipboardData) && t.preventDefault() } cut(t) { this.copyFragment(t.clipboardData, !0) && t.preventDefault() } paste(t) { const e = D(this.target), s = this.model.getById(parseInt(e.from.key)), i = { type: "plain" }; s && s.name === "pre" && (i.noSplit = !0); let n = t.clipboardData.getData(this.fragmentMIME), u; n ? (n = JSON.parse(n), i.type = "fragment") : t.clipboardData.types.includes("text/html") ? (n = t.clipboardData.getData("text/html"), i.type = "html") : t.clipboardData.types.includes("Files") ? this.pasteFiles(t, e) : n = t.clipboardData.getData("text/plain"); const o = (l, a) => !l || !e ? null : (t.stopPropagation(), t.preventDefault(), this.model.paste(l, e.from, e.to, a)); try { u = o(n, i) } catch { if (i.type === "plain") return; n = t.clipboardData.getData("text/plain"), i.type = "plain", u = o(n, i) } u && (this.setRange(this.target, u.to), this.editor.modules.autoFormat && this.editor.modules.autoFormat.onPaste()) } pasteFiles(t, e) { this.editor.modules.files && (t.stopPropagation(), t.preventDefault(), this.editor.modules.files.add(t.clipboardData.files, e.from)) }
} class Fs { constructor(t, e, s, i = {}) { i.last_empty_line == null && (i.last_empty_line = !0), this.editor = t, this.model = t.model, this.container = s, this.target = e, this.enableLEL = !!i.last_empty_line, this.empty = null } update() { const t = this.isEmpty(); this.editor.events && t !== this.empty && this.editor.events.emit("change:empty", t), this.empty = t, this.hasLEL() || this.addLEL() } destroy() { } _getLast() { const t = this.model.state.value; return t[t.length - 1] } _isEmptyLine(t) { return !!(t && t.name === "p" && t.value.length === 0) } _isAbsentChildren() { return this.model.state.value.length === 0 } isEmpty() { const t = this.model.state.value; if (t.length > 1) return !1; const e = t[0]; return !!(!e || this._isEmptyLine(e)) } getLast() { const t = this._getLast(); return t ? t.id : null } hasLEL() { const t = this._getLast(); return !!this._isEmptyLine(t) } getLEL() { const t = this._getLast(); return t && this._isEmptyLine(t) ? t.id : null } addLEL() { if (!this.enableLEL && !this._isAbsentChildren()) return; const t = this._getLast(); return t ? this.model.insertAfter("p", t.id, null, !1) : this.model.append("p", 0) } } class As {
	constructor(t, e, s, i = {}) { this.events = new W, this.editor = t, this.model = t.model, this.container = s, this.target = e, this.params = L(!0, this.defaultParams, i), Object.defineProperties(this, { _draging: { value: !1, enumerable: !1, writable: !0 }, _count: { value: 0, enumerable: !1, writable: !0 }, _moused: { value: !1, enumerable: !1, writable: !0 }, _started: { value: !1, enumerable: !1, writable: !0 } }), this.delegateEvents(), this.buildMap() } get defaultParams() {
		return {
			blockClass: "rich-text-drop", showClass: "m_show", draggingClass: "m_dragging", template: `<svg width="700" height="30" viewBox="0 0 700 30" fill="none" xmlns="http://www.w3.org/2000/svg">
				<rect width="700" height="30" rx="7" fill="black"/>
			</svg>`}
	} update() { this.buildMap() } destroy() { this.events.off(), this.dispose() } get moused() { return this._moused } set moused(t) { this._moused = t } get draging() { return this._draging } set draging(t) { this._draging = t } get dragCount() { return this._count } set dragCount(t) { this._count = t } get started() { return this._started } set started(t) { this._started = t } get fragmentMIME() { return "teletype/fragment" } get rangeMIME() { return "teletype/range" } createPlaceholder() { const t = document.createElement("div"); return t.innerHTML = `${this.params.template}`, t.classList.add(this.params.blockClass), this.target.appendChild(t), this._placeholder = t } placePlaceholder(t) { this._placeholder && (this._placeholder.style.top = `${t}px`, this._placeholder.classList.add(this.params.showClass)) } dispose() { this.target.classList.remove(this.params.draggingClass), this._placeholder && (this._placeholder.remove(), this._placeholder = null, delete this._placeholder, delete this._position), this._childmap && this._childmap.forEach(t => { t.el.style.transform = "" }) } delegateEvents() { return this.events.on("mousedown", document.body, t => this._mouseDown(t)), this.events.on("mouseup", document.body, t => this._mouseUp(t)), this.events.on("dragstart", document.body, t => this._start(t)), this.events.on("dragend", document.body, t => this._end(t)), this.events.on("dragenter", document.body, t => this._enter(t)), this.events.on("dragover", document.body, t => this._over(t)), this.events.on("dragleave", document.body, t => this._leave(t)), this.events.on("drop", document.body, t => this._drop(t)), this } undelegateEvents(t = null, e = null) { return this.events.off(t, e), this } _mouseDown() { return this.moused = !0, !0 } _mouseUp() { return this.moused = !1, !0 } _start(t) { this.started = !0, this.dragContent(t) } _end(t) { return this.draging = !1, this.dragCount = 0, this.dragEnd(t), !0 } _enter(t) { t.preventDefault(), t.stopPropagation(), this.dragCount == 0 && this.dragStart(t), this.dragCount++ } _over(t) { t.dataTransfer.dropEffect = "copy", t.preventDefault(), t.stopPropagation(), this.drag(t) } _leave(t) { return t.preventDefault(), t.stopPropagation(), this.dragCount--, this.draging = !1, this.dragCount <= 0 && this.dragEnd(t), !0 } _drop(t) { t.preventDefault(), t.stopPropagation(), this.dragCount--, this.draging = !1, this.dragEnd(t), this.drop(t) } buildMap() {
		const t = [], e = document.createElement("p"); e._fake_ = !0, this.target.appendChild(e), [].slice.call(this.target.children).forEach((s, i) => {
			if (s._fake_) return; let n = this.target.children[i + 1], u = s.offsetTop, o = s.offsetHeight, l = n ? n.offsetTop : u + o, a = u + o / 2, c = !s.innerText.replace(`
`, ""); s.isContentEditable || (c = !1), t.push({ el: s, start: u, height: o, end: l, center: a, empty: c })
		}), this._childmap = t, e.remove()
	} getPosition(t) { var e = null, s = null, i = null, n = this.target.getBoundingClientRect().top || 0; return this._childmap.forEach((u, o) => { o === 0 && (s = u.el), !(t.clientY - n < u.center && !(e != null && e.item.empty)) && (i = this._childmap[o + 1], e = { item: u, index: o }) }), { index: e ? e.index : -1, el: e ? e.item.el : null, top: e ? e.item.end : 0, next: i, first: s } } dragContent(t) { t.dataTransfer.effectAllowed = "copyMove"; const e = D(this.target); e ? t.dataTransfer.setData(this.rangeMIME, JSON.stringify(e)) : t.preventDefault() } dragStart() { for (let t in this.editor.modules) t !== "dragAndDrop" && this.editor.modules[t].dispose && this.editor.modules[t].dispose(); this.buildMap(), this.createPlaceholder(), this.target.classList.add(this.params.draggingClass) } drag(t) { let e = this.getPosition(t), s = this._placeholder.offsetHeight, i = s + s * .5; this._position && e.index === this._position.index || !this._childmap || (this._childmap.forEach((n, u) => { u <= e.index || (e.next != null ? e.next.empty : void 0) ? n.el.style.transform = "" : n.el.style.transform = `translateY(${i}px)` }), this.placePlaceholder(e.top), this._position = e) } dragEnd() { this.dispose() } drop(t) { t.preventDefault(); const e = this.getPosition(t); if (!e || !e.el && !e.first) return; let s; e.next && e.next.empty ? s = parseInt(I(e.next.el)) : s = e.el ? this.model.insertAfter("p", parseInt(I(e.el)), null, !1) : this.model.insertBefore("p", parseInt(I(e.first)), null, !1); const i = { pos: 0, key: s }; if (!i) return; const n = t.dataTransfer.types.includes(this.rangeMIME), u = t.dataTransfer.types.includes("text/html"), o = t.dataTransfer.types.includes("text/plain"), l = t.dataTransfer.files.length > 0; if (n) { const a = t.dataTransfer.getData(this.rangeMIME), c = JSON.parse(a), d = this.model.move(c.from, c.collapsed ? null : c.to, i, t.dataTransfer.dropEffect !== "move" && !t.altKey); C(this.target, d.to, d.to) } else if (u) { const a = t.dataTransfer.getData("text/html"), c = this.model.paste(a, i, null, { type: "html" }); C(this.target, c.to, c.to) } else if (o) { const a = t.dataTransfer.getData("text/plain"), c = this.model.paste(a, i); C(this.target, c.to, c.to) } else l && this.editor.modules.files && this.editor.modules.files.add(t.dataTransfer.files, i) }
} class xs { constructor(t, e, s, i = {}) { this.editor = t, this.model = t.model, this.container = s, this.target = e, this.params = L(!0, this.defaultParams, i) } get defaultParams() { return { formatters: [{ type: "block", value: "h2", exp: /^#{1,2}\s$/ }, { type: "block", value: "h3", exp: /^#{3,6}\s$/ }, { type: "block", value: "ul", exp: /^[*-]\s+$/ }, { type: "block", value: "ol", exp: /^\d+\.\s+$/ }, { type: "block", value: "blockquote", exp: /^>\s+$/ }, { type: "block", value: "pre", exp: /^```$/, exclude: ["pre"] }, { type: "block", value: "tags", exp: /^#([^\s#][\s\S]*)/g, exclude: ["pre"] }, { type: "widget", value: "hr", exp: /^([*=_-]{3,})$/g, exclude: ["pre"] }, { type: "format", value: "link", text_as_value: !0, exp: /(\bhttps?:\/\/[-A-Z0-9+&@#/%?=~_|!:,.;]*[-A-Z0-9+&@#/%=~_|])/gi, exclude: ["pre"] }, { type: "format", value: "bold", exp: /\*([^\s*][\s\S]*?[^\s])\*(?!\*)/g, input_exp: /(^|\s)\*([^\s*][\s\S]*?[^\s])\*(?!\*)$/, exclude: ["pre"] }, { type: "format", value: "italic", exp: /_([^\s_][\s\S]*?[^\s])_(?!_)/g, input_exp: /(^|\s)_([^\s_][\s\S]*?[^\s])_(?!_)$/, exclude: ["pre"] }, { type: "format", value: "strike", exp: /~([^\s~][\s\S]*?[^\s])~(?!~)/g, input_exp: /(^|\s)~([^\s~][\s\S]*?[^\s])~(?!~)$/, exclude: ["pre"] }, { type: "format", value: "code", exp: /`([^`][\s\S]*?)`(?!`)/g, input_exp: /(^|\s)`([^`][\s\S]*?)`(?!`)$/, exclude: ["pre"] }, { type: "replace", value: "\u2014 ", exp: /--\s/gi, exclude: ["pre"] }] } } update() { } destroy() { } onInput() { if (this.model.canRedo()) return; const t = D(this.target); !t || this.parse(t, !0) } onPaste() { const t = D(this.target); !t || this.parse(t) } _isAllowedItem(t) { const e = this.editor.params.items; return !(e.length > 0 && !e.includes(t)) } _isAllowedFormat(t) { const e = this.editor.params.formats; return !(e.length > 0 && !e.includes(t)) } parse(t, e = !1) { if (!t.collapsed) return; const s = this.model.getById(parseInt(t.from.key)); if (!(!s || s.type !== "formatted-string")) return this._parse(t.from, s, e) } _parse(t, e, s) { const i = b(e.value); let n = !1, u = 0; return !s || t.pos !== i.length || (this.params.formatters.forEach(o => { const l = s && o.input_exp || o.exp; if (!i.match(l) || !this[o.type] || (o.exclude || []).includes(e.name)) return; let a, c; for (; (a = o.exp.exec(i)) !== null && (c = this[o.type](a, o.value, o, t.key, u, e), u += c.remove, n = c.override != null ? c.override : n, !!o.exp.global);); }), n && this.editor.setRange({ key: t.key, pos: t.pos - u })), n } widget(t, e, s, i) { if (!this._isAllowedItem(e)) return { remove: 0 }; const n = parseInt(i); return this.model.convert(e, n, n, !0), { remove: 0, override: !0 } } block(t, e, s, i) { if (!this._isAllowedItem(e)) return { remove: 0 }; const n = t[0].length, u = t[1] || ""; return this.model.replaceText({ key: i, pos: 0 }, { key: i, pos: n }, u, !1), this.model.convert(e, parseInt(i), null, !0), { remove: n - u.length, override: !0 } } replace(t, e = "", s, i, n = 0) { const u = t.index - n, o = t[0].length; let l = u, a = l + o; this.model.replaceText({ key: i, pos: l }, { key: i, pos: a }, e, !0), a = l + e.length; const c = o - e.length; return { remove: c, override: c > 0 } } format(t, e, s, i, n, u) { if (!this._isAllowedFormat(e)) return { remove: 0 }; const o = t.index - n, l = t[0].length, a = t[1] || "", c = s.text_as_value ? a : !0, d = { [e]: c }; let h = o, p = h + l, f = 0, g = !1; if (u.value.forEach(w => { const $ = f + w.text.length; g || (g = h === f && p === $ && w.format[e] === d[e]), !g && (f >= h && f < p || $ > h && $ <= p) && this.model.setFormat({ [e]: !1 }, { key: i, pos: f }, { key: i, pos: f + w.text.length }, !1), f += w.text.length }), g) return { remove: 0 }; this.model.replaceText({ key: i, pos: h }, { key: i, pos: p }, a, !1), p = h + a.length, this.model.setFormat(d, { key: i, pos: h }, { key: i, pos: p }, history); const y = l - a.length; return { remove: y, override: y > 0 } } } class _s { constructor(t, e, s, i = {}) { this.events = new W, this.editor = t, this.model = t.model, this.container = s, this.target = e, this.params = L(!0, this.defaultParams, i), this._pos = null, this._el = null, this.create() } get defaultParams() { return { upload: e => this._fakeUpload(e), maxFilesUpload: 20, accept: [{ type: "image", file_type: "jpg", ext: ".jpg", mimes: ["image/jpeg"], max_size: 5242880 }, { type: "image", file_type: "png", ext: ".png", mimes: ["image/png"], max_size: 5242880 }, { type: "image", file_type: "gif", ext: ".gif", mimes: ["image/gif"], max_size: 5242880 }] } } update() { } destroy() { this.events.off(), this.input.remove() } create() { const t = document.createElement("input"); t.type = "file", t.multiple = !0, t.accept = this.getAcceptMimes().join(","), t.style.cssText = "position: absolute; top: -99999px; left: -99999px;", this.container.appendChild(t), this.input = t, this.input.addEventListener("click", e => { e.stopPropagation() }) } getAcceptMimes() { let t = []; return this.params.accept.forEach(e => { t = t.concat(e.mimes) }), t } getAcceptByMime(t) { return this.params.accept.find(e => e.mimes.includes(t)) } checkDisallowed(t, e) { return t ? e.size >= t.max_size ? "file_to_large" : null : "unsupported_media_type" } open(t) { this.input.onchange = e => { e.currentTarget.files.length > 0 && this.add(e.currentTarget.files, t) }, this.input.click() } add(t, e) { if (t.length === 0 || !e) return; let s = this.model.getById(parseInt(e.key)), i; const n = this.editor.modules.emptyController ? this.editor.modules.emptyController.getLast() : null, u = (a, c) => { let d = !1, h = a, p = a.id; return a.id === n && this.model.insertAfter("p", a.id, {}, !1), a.name !== c.type && (a.value.length === 0 ? this.model.convert(c.type, a.id, a.id, !1) : (p = this.model.insertAfter(a.name, a.id, {}, !1), this.model.convert(c.type, p, p, !1)), d = !0, h = this.model.getById(p)), { node: h, removeOnError: d } }, o = (a, c) => { let d = !0, h = this.model.insertAfter(c.type, a.id, null, !1); return { node: this.model.getById(h), removeOnError: d } }, l = a => { const c = this.getAcceptByMime(a.type), d = this.checkDisallowed(c, a); if (d) return this.editor.events && this.editor.events.trigger("files:error", d), d; let { node: h, removeOnError: p } = i ? o(i, c) : u(s, c); i = h, typeof this[`_${c.type}Load`] == "function" && this[`_${c.type}Load`](h, a, p) }; Array.from(t).slice(0, this.params.maxFilesUpload || Number.MAX_SAFE_INTEGER).forEach(l) } _imageLoad(t, e, s) { const i = URL.createObjectURL(e), n = { ...t.value }; let u = { src: i, width: null, height: null, naturalWidth: null, naturalHeight: null }; this.model.assign(t.id, u, !1), typeof this.params.upload == "function" && this.params.upload(e).then(o => { let { width: l, height: a, naturalWidth: c, naturalHeight: d } = o, h = o.url || o.src; u = { ...u, src: h, width: l, height: a, naturalWidth: c, naturalHeight: d }, this.model.assign(t.id, u), URL.revokeObjectURL(h) }).catch(() => { this.editor.events && this.editor.events.trigger("files:error", "failed_to_upload"), s ? this.model.removeNode(t.id, !1) : this.model.assign(t.id, n, !1), URL.revokeObjectURL(i) }) } _fakeUpload() { return new Promise((t, e) => { setTimeout(() => { e("upload_method_not_defined") }, 1e3) }) } } class bs { constructor(t, e, s, i = {}) { this.editor = t, this.model = t.model, this.container = s, this.target = e, this.params = L(!0, this.defaultParams, i) } get defaultParams() { return { links: { youtube: /^((\w+:)?\/\/)?(?:www\.|m\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|live\/|shorts\/|v\/|watch\?v=|watch\?.+&v=))([^#&?\s\n]+)/i, vimeo: /^(?:(?:\w+:)?\/\/)?(?:\w+\.)?vimeo\..*?\/(\d+)(?:\/([0-9a-z]+))?/i, twitter: /(www\.|mobile\.)?twitter\.com\/(.+)\/status\/(\d+)/i, facebook: /^((\w+:)?\/\/)?(?:www\.)?facebook\.com\/(.+)/i, tiktok: /^((\w+:)?\/\/)?(?:www\.)?tiktok\.com\/(?:.*?)\/(\d+)/i, telegram: /^(?:https?:)?(?:\/\/)?(?:t\.me|telegram\.me)\/(?:@?([a-z0-9_-]+))\/(\d+)/i, instagram: /^((\w+:)?\/\/)?(?:www\.)?(?:instagr\.am|instagram\.com)\/(?:p|tv)\/(.+)/i, figma: /^((\w+:)?\/\/)?(?:www\.)?figma\.com\/(file|embed)/i, jsfiddle: /^((\w+:)?\/\/)?(?:www\.)?jsfiddle\.net\/([a-z0-9_-]+)/i, codepen: /^((\w+:)?\/\/)?(?:www\.)?codepen\.io\/(?:(.+)\/)?(?:pen|embed)\/(.+)/i, gist: /^((\w+:)?\/\/)?gist\.github\.com\/(.+?)\/([0-9a-f]+)/i, soundcloud: /^((\w+:)?\/\/)?(www\.|api\.|w\.)?soundcloud\.com\/(.+)/i, anchorfm: /^((\w+:)?\/\/)?(?:www\.)?anchor.fm\/(.+?)\/(.+)/i, applepodcast: /^((\w+:)?\/\/)?(www\.|embed\.)?podcasts\.apple\.com\/(.+)/i, spotify: /^((\w+:)?\/\/)?open\.spotify\.com\/(.+)/i, yamusic: /^((\w+:)?\/\/)?music\.yandex\.ru\/(.+)/i, yamaps: /^((\w+:)?\/\/)?(?:www\.)?yandex\.(?:\w{2,3})\/(?:maps|web-maps|map-widget\/v1)/i, image: /\.(jpe?g|png|gif)(\?.*)?$/i, video: /\.mp4(\?.*)?$/i } } } update() { } destroy() { } link(t, e) { if (!e) return !1; const s = this.params.links, i = this.editor.params.items; let n = null; return Object.keys(s).forEach(u => { i && i.length > 0 && i.indexOf(u) === -1 || e.match(s[u]) && (n = u) }), n ? this.add(t, n, { src: e }) : !1 } code(t, e) { if (!e) return !1; const s = this.params.links, i = document.createElement("DIV"); i.innerHTML = e.replace(/\s+/g, " "); const n = i.querySelector("iframe"); if (n == null || n.src == null) return !1; let u = "iframe"; Object.keys(s).forEach(l => { n.src.match(s[l]) && (u = l) }); let o = {}; return o.src = n.src, o.width = n.width && n.width.slice(-1) !== "%" ? parseInt(n.width) : null, o.height = n.height && n.height.slice(-1) !== "%" ? parseInt(n.height) : null, Object.keys(n.dataset).forEach(l => { o[l] = n.dataset[l] }), this.add(t, u, o) } add(t, e, s) { const i = Number(t.key); let n = this.model.getById(i); return n.name !== e && (this.model.convert(e, n.id, n.id, !1), n = this.model.getById(i)), this.model.assign(n.id, s), n.id } parse(t) { const e = this.model.getById(parseInt(t.from.key)); return !e || e.type === "container" || e.type !== "formatted-string" || e.name !== "p" || e.value.length !== 1 ? !1 : this.link(t.from, e.value[0].text) } } class $s { constructor(t, e, s = {}) { this.defaults = { container: document.scrollingElement || document.body, modules: { emptyController: !0, mediaToolbar: !0, dragAndDrop: !0, autoFormat: !0, files: !0, media: !0 }, placeholders: { editor: "Start your story rignt now...", caption_image: "Image caption", caption: "Caption" }, items: [], formats: [], options: { media_caption: !0 } }, this.params = L(!0, this.defaults, s), this.events = new Te, this.modules = {}, this.target = t; const i = { items: this.params.items, formats: this.params.formats }, n = new Vt(e || "<document><p></p></document>", i); this.model = n, this.initRichEditor(), setTimeout(() => { this.update(n.state, n) }, 0), this._unsubscribeModel = n.subscribe(u => this.update(u, n)) } initRichEditor() { this.renderer = new ps(this, this.model, this.target), this.actions = new Es(this, this.model, this.target, this.params.container), this.input = new ws(this, this.model, this.target); const t = this.params.modules; for (let e in t) { let s = t[e] === !0 ? {} : t[e]; switch (e) { case "emptyController": s && this.registerModule(e, s.module || Fs, s, !1); break; case "dragAndDrop": s && this.registerModule(e, s.module || As, s, !1); break; case "autoFormat": s && this.registerModule(e, s.module || xs, s, !1); break; case "files": s && this.registerModule(e, s.module || _s, s, !1); break; case "media": s && this.registerModule(e, s.module || bs, s, !1); break; default: typeof s == "function" ? this.registerModule(e, s) : typeof s == "object" && s.module && this.registerModule(e, s.module, s) } } } update(t, e) { this.renderer.update(t, e), setTimeout(() => { for (let s in this.modules) this.modules[s].update(t, e); this.events.emit("update") }, 0) } registerModule(t, e, s, i = !0) { this.unregisterModule(t); const n = (u, o = !1) => { this.modules[t] = new u(this, this.target, this.params.container, s), i && (o ? this.update(this.model.state, this.model) : this.modules[t].update(this.model.state, this.model)), this.events.emit("register", t, this.modules[t]) }; e.prototype ? n(e) : e().then(u => n(u.default, !0)) } unregisterModule(t) { this.modules[t] && (this.modules[t].destroy(), delete this.modules[t], this.events.emit("unregister", t)) } getModelRange() { return D(this.target) } getRange() { return E(this.target) } setRange(t) { return C(this.target, t) } focus() { return this.actions.focus() } serialize(t) { return this.model.serialize(t) } on(...t) { this.events.on.apply(this.events, t) } once(...t) { this.events.once.apply(this.events, t) } off(...t) { this.events.off.apply(this.events, t) } destroy() { this._unsubscribeModel(); for (let t in this.modules) this.modules[t].destroy(); this.renderer.destroy(), this.actions.destroy(), this.input.destroy() } get utils() { return { ...oe, ...he, ...ie, html: m } } } export { $s as default };
